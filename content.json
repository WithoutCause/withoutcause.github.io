{"meta":{"title":"杰灵的博客","subtitle":"","description":"","author":"杰灵","url":"https://withoutcause.github.io","root":"/"},"pages":[{"title":"categories","date":"2021-07-21T11:43:34.000Z","updated":"2021-07-21T11:45:02.028Z","comments":false,"path":"categories/index.html","permalink":"https://withoutcause.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-07-21T11:36:25.000Z","updated":"2021-07-21T11:45:06.406Z","comments":false,"path":"tags/index.html","permalink":"https://withoutcause.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"自学ES-03之文档","slug":"自学ES-03之文档","date":"2022-04-14T16:24:02.000Z","updated":"2023-01-17T00:34:02.000Z","comments":true,"path":"2022/04/15/自学ES-03之文档/","link":"","permalink":"https://withoutcause.github.io/2022/04/15/%E8%87%AA%E5%AD%A6ES-03%E4%B9%8B%E6%96%87%E6%A1%A3/","excerpt":"文档写入单条写入ES 中文档写入是 POST 请求。","text":"文档写入单条写入ES 中文档写入是 POST 请求。 1POST /&#123;index_name&#125;/_doc/&#123;_id&#125; {index_name} : 索引名称，必须有。 {_id} 可以没有，如果没有 ES 会自动生成，并在写入成功后返回。如果有，使用指定的 id。 示例 1234567891011121314151617181920POST /sjl/_doc/001&#123; &quot;title&quot;: &quot;工程师&quot;&#125;响应如下：&#123; &quot;_index&quot; : &quot;sjl&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;002&quot;, &quot;_version&quot; : 1, &quot;result&quot; : &quot;created&quot;, &quot;_shards&quot; : &#123; &quot;total&quot; : 2, &quot;successful&quot; : 1, &quot;failed&quot; : 0 &#125;, &quot;_seq_no&quot; : 7, &quot;_primary_term&quot; : 3&#125; 批量写入ES 批量写入，统一调 _bulk 。 12345POOST /_bulk&#123;&quot;index&quot;: &#123;&quot;_index&quot;: index_name, _id:id&#125;&#123;&quot;data&quot;: xxx&#125;&#123;&quot;index&quot;: &#123;&quot;_index&quot;: index_name, _id:id&#125;&#123;&quot;data&quot;: xxx&#125; index_name：索引名称 _id: 可以省略 示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647POST /_bulk&#123;&quot;index&quot;: &#123;&quot;_index&quot;: &quot;sjl&quot;, &quot;_id&quot;: &quot;003&quot;&#125;&#125;&#123;&quot;title&quot;: &quot;工程师3&quot;&#125;&#123;&quot;index&quot;: &#123;&quot;_index&quot;: &quot;sjl&quot;, &quot;_id&quot;: &quot;004&quot;&#125;&#125;&#123;&quot;title&quot;: &quot;工程师4&quot;&#125;----- 响应信息---------&#123; &quot;took&quot; : 5, &quot;errors&quot; : false, &quot;items&quot; : [ &#123; &quot;index&quot; : &#123; &quot;_index&quot; : &quot;sjl&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;003&quot;, &quot;_version&quot; : 1, &quot;result&quot; : &quot;created&quot;, &quot;_shards&quot; : &#123; &quot;total&quot; : 2, &quot;successful&quot; : 1, &quot;failed&quot; : 0 &#125;, &quot;_seq_no&quot; : 8, &quot;_primary_term&quot; : 3, &quot;status&quot; : 201 &#125; &#125;, &#123; &quot;index&quot; : &#123; &quot;_index&quot; : &quot;sjl&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;004&quot;, &quot;_version&quot; : 1, &quot;result&quot; : &quot;created&quot;, &quot;_shards&quot; : &#123; &quot;total&quot; : 2, &quot;successful&quot; : 1, &quot;failed&quot; : 0 &#125;, &quot;_seq_no&quot; : 9, &quot;_primary_term&quot; : 3, &quot;status&quot; : 201 &#125; &#125; ]&#125; 在某些情况下，我们直接使用 curl 读取一个文件也可以完成批量的写入。原理：curl 从文件读数据，然后调 ES 批量写入接口进行数据写入。 示例 1curl -s -X POST &#x27;ES:9200/_bulk?preety&#x27; --data-binary &quot;@bulk_doc.json&quot; -s: 不输出错误和进度信息 -X: 请求请求方式为 POST –data-binary：二进制POST 的请求体 @bulk_doc.json：指定文件目录 文档修改单条修改1234567POST /&#123;idnex_name&#125;/_update/&#123;_id&#125;&#123; &quot;doc&quot;: &#123; &quot;修改字段名&quot;: &quot;修改字段值”， xxx: xx &#125;&#125; 示例 1234567891011121314151617181920212223242526272829303132333435363738394041-----查询 sjl索引下的id：004 数据------GET /sjl/_doc/004&#123; &quot;_index&quot; : &quot;sjl&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;004&quot;, &quot;_version&quot; : 3, &quot;_seq_no&quot; : 11, &quot;_primary_term&quot; : 3, &quot;found&quot; : true, &quot;_source&quot; : &#123; &quot;title&quot; : &quot;工程师4&quot; &#125;&#125;------- 修改数据-----------POST /sjl/_update/004&#123; &quot;doc&quot;: &#123; &quot;age&quot;: 26 &#125; &#125;#这条数据原来是有一个 title: 工程师4的数据在#查询一下结果GET /sjl/_doc/004---- 返回结果-----&#123; &quot;_index&quot; : &quot;sjl&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;004&quot;, &quot;_version&quot; : 3, &quot;_seq_no&quot; : 11, &quot;_primary_term&quot; : 3, &quot;found&quot; : true, &quot;_source&quot; : &#123; &quot;title&quot; : &quot;工程师4&quot;, &quot;age&quot; : 26 &#125;&#125; 批量修改文档删除单条删除批量删除文档查询","categories":[{"name":"ES","slug":"ES","permalink":"https://withoutcause.github.io/categories/ES/"}],"tags":[{"name":"ES","slug":"ES","permalink":"https://withoutcause.github.io/tags/ES/"}]},{"title":"自学ES-02之索引CRUD","slug":"自学ES-02之索引CRUD","date":"2022-04-14T16:23:31.000Z","updated":"2022-04-14T16:23:31.000Z","comments":true,"path":"2022/04/15/自学ES-02之索引CRUD/","link":"","permalink":"https://withoutcause.github.io/2022/04/15/%E8%87%AA%E5%AD%A6ES-02%E4%B9%8B%E7%B4%A2%E5%BC%95CRUD/","excerpt":"[toc] 注：下面的操作都是在 kibana 中进行的。 索引(index)","text":"[toc] 注：下面的操作都是在 kibana 中进行的。 索引(index)索引的创建1234567891011PUT /&#123;index_name&#125;&#123; settings: &#123; ... &#125; mappings: &#123; properties: &#123; ... &#125; &#125;&#125; 索引查看1GET /&#123;index_name&#125; 索引删除1DELETE /&#123;index_name&#125; 索引打开和关闭ES 支持对索引进行关闭操作，关闭后也可以重新打开。索引一旦关闭： 不能写入数据 不能搜索数据 kibana 1POST /&#123;index_name&#125;/_close 索引关闭后，再对索引进行数据写入或搜索，将返回如下报错信息： 1234567891011121314151617&#123; &quot;error&quot; : &#123; &quot;root_cause&quot; : [ &#123; &quot;type&quot; : &quot;index_closed_exception&quot;, &quot;reason&quot; : &quot;closed&quot;, &quot;index_uuid&quot; : &quot;wnmGfLi-TPCanl-YuBNojg&quot;, &quot;index&quot; : &quot;sjl&quot; &#125; ], &quot;type&quot; : &quot;index_closed_exception&quot;, &quot;reason&quot; : &quot;closed&quot;, &quot;index_uuid&quot; : &quot;wnmGfLi-TPCanl-YuBNojg&quot;, &quot;index&quot; : &quot;sjl&quot; &#125;, &quot;status&quot; : 400&#125; 打开索引 1POST /&#123;index_name&#125;/_open 索引别名可以对多个索引设置相同的别名，从而将这些索引通过别名进行聚合，然后再对设置别名的索引进行操作，就相当于是在同时操作这些别名匹配的索引。 映射(mappings)创建映射映射是在创建索引时一并指定。映射可以理解为关系型数据库中的表定义。一张表有哪些字段，每个字段什么类型。 查看映射12345678910111213GET /&#123;index_name&#125;/_mapping#返回数据&#123; &quot;sjl&quot; : &#123; #索引名称 &quot;mappings&quot; : &#123; #映射相关信息 &quot;properties&quot; : &#123; &quot;title&quot; : &#123; &quot;type&quot; : &quot;keyword&quot; &#125; &#125; &#125; &#125;&#125; 修改映射映射不能修改，只能扩展。，如果需要修改映射的字段类型的时候应该怎么办？ 123456789# 扩展映射 POST /sjl/_mapping&#123; &quot;properties&quot;: &#123; &quot;name&quot;: &#123; &quot;type&quot;: &quot;text&quot; &#125; &#125;&#125; 数据类型keywordkeyword 类型是不能再切分的字符串类型。在搜索的时候，不对 keyword 类型的字符串进行切分后的部分匹配。使用 term 查询数据。 texttext 精英是可切分的字符串类型。在搜索的时候，会按照分词算法对 text 类型的字符串进行切分后匹配。使用 match 查询数据。 数值类型 long(长整型):8字节，64位, $-2^{63}$ —— $2^{63}$-1 integer(整型):4字节，32位，$-2^{31}$ —— $2^{31}$-1 short(短整型):2字节，16位，$-2^{15}$ —— $2^{15}$-1 byte(字节):1字符，8位，$-2^{7}$ —— $2^{7}$，即 -128——127 double(双精度):8字节，64位。 float(单精度)：4字节，32位 half_float(半精度)：2字符，16位。 scaled_float(缩放浮点型) unsigned_long(无符号长整形)：6字节，64位。$2^{64}-1$ 布尔(boolean) true 或 “true” false 或 “false” 日期类型(date)日期类型为两种： strict_date_optional_time：严格的日期类型，yyyy-MM-dd、yyyyMMdd、yyyyMMddHHmmss、yyyy-MM-ddTHH:mm:ss、yyyy-MM-ddTHH:mm:ss.SSS和yyyy-MM-ddTHH:mm:ss.SSSZ epoch_millis：时间戳类型 数组ES 定义的格式，自动支持数组。在定义时，使用数组的内容项的类型定义 mapping 即可。写入数据时，使用 [] 的形式。 1234POST /&#123;index_name&#125;/001&#123; &quot;tag&quot;: [&quot;tag1&quot;, &quot;tag2&quot;]&#125; tag 定义的是 keyword 的类型。 对象与普通的对象操作一致。 示例： 1","categories":[{"name":"ES","slug":"ES","permalink":"https://withoutcause.github.io/categories/ES/"}],"tags":[{"name":"ES","slug":"ES","permalink":"https://withoutcause.github.io/tags/ES/"}]},{"title":"自学ES-01之环境安装","slug":"自学ES-01之环境安装","date":"2022-04-14T16:23:19.000Z","updated":"2022-04-14T16:23:19.000Z","comments":true,"path":"2022/04/15/自学ES-01之环境安装/","link":"","permalink":"https://withoutcause.github.io/2022/04/15/%E8%87%AA%E5%AD%A6ES-01%E4%B9%8B%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/","excerpt":"[toc] 搭建本地 Docker 的环境，仅供练习使用。 ES 环境安装","text":"[toc] 搭建本地 Docker 的环境，仅供练习使用。 ES 环境安装1docker run -d --name es -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; -e &quot;ES_JAVA_OPTS=-Xmx512M -Xms512M&quot; -e &quot;xpack.security.enabled=false&quot; elasticsearch:7.16.3 1docker run -d --name es -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; -e &quot;ES_JAVA_OPTS=-Xmx512M -Xms512M&quot; elasticsearch:7.16.3 ES_JAVA_OPTS=-Xmx512M -Xms512M: 配置 ES 的内存为 512M。 xpack.security.enabled:配置是因为查询的时候，在 kibana 界面会出现一个安全提示，该配置在生产中需要开启(设置为:true)。 Kibana 环境安装1docker run -it -d --name kibana --link es -e ELASTICSEARCH_HOSTS=http://es:9200 -p 5601:5601 kibana:7.16.3","categories":[{"name":"ES","slug":"ES","permalink":"https://withoutcause.github.io/categories/ES/"}],"tags":[{"name":"ES","slug":"ES","permalink":"https://withoutcause.github.io/tags/ES/"}]},{"title":"自学ES-00之目录","slug":"自学ES-00之目录","date":"2022-04-14T16:21:16.000Z","updated":"2023-01-17T08:15:16.000Z","comments":true,"path":"2022/04/15/自学ES-00之目录/","link":"","permalink":"https://withoutcause.github.io/2022/04/15/%E8%87%AA%E5%AD%A6ES-00%E4%B9%8B%E7%9B%AE%E5%BD%95/","excerpt":"自学ES-01之环境安装 自学ES-02之索引CRUD 自学ES-03之文档","text":"自学ES-01之环境安装 自学ES-02之索引CRUD 自学ES-03之文档","categories":[{"name":"ES","slug":"ES","permalink":"https://withoutcause.github.io/categories/ES/"}],"tags":[{"name":"ES","slug":"ES","permalink":"https://withoutcause.github.io/tags/ES/"}]},{"title":"重学Java并发——01之线程基础","slug":"重学Java并发——01之线程基础","date":"2021-11-24T12:46:13.000Z","updated":"2021-11-24T12:46:13.000Z","comments":true,"path":"2021/11/24/重学Java并发——01之线程基础/","link":"","permalink":"https://withoutcause.github.io/2021/11/24/%E9%87%8D%E5%AD%A6Java%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%9401%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/","excerpt":"多线程多线程的状态java.lang.Thread.State 定义了线程的状态。","text":"多线程多线程的状态java.lang.Thread.State 定义了线程的状态。 NEW RUNNABLE BLOCKED WAITINT WAIT_TIMEOUT TERMINTED","categories":[],"tags":[]},{"title":"重学Java并发——00之目录","slug":"重学Java并发——00之目录","date":"2021-11-24T12:45:34.000Z","updated":"2021-11-24T12:45:34.000Z","comments":true,"path":"2021/11/24/重学Java并发——00之目录/","link":"","permalink":"https://withoutcause.github.io/2021/11/24/%E9%87%8D%E5%AD%A6Java%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%9400%E4%B9%8B%E7%9B%AE%E5%BD%95/","excerpt":"","text":"目录 重学Java并发——01之线程基础 对自己说","categories":[{"name":"并发","slug":"并发","permalink":"https://withoutcause.github.io/categories/%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"并发","slug":"并发","permalink":"https://withoutcause.github.io/tags/%E5%B9%B6%E5%8F%91/"},{"name":"多线程","slug":"多线程","permalink":"https://withoutcause.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"多个三方对接实践——数据中心","slug":"多个三方对接实践——数据中心","date":"2021-11-22T14:17:29.000Z","updated":"2021-11-22T14:17:29.000Z","comments":true,"path":"2021/11/22/多个三方对接实践——数据中心/","link":"","permalink":"https://withoutcause.github.io/2021/11/22/%E5%A4%9A%E4%B8%AA%E4%B8%89%E6%96%B9%E5%AF%B9%E6%8E%A5%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83/","excerpt":"概述业务发展需要对接到多个三方系统，涉及到多项业务。内部有多条业务线，每条业务线都有对应的系统支撑。每个系统都需要对接一些第三方系统，在各个业务中会有一些重合。所以我们希望： 不同的业务线如果要对接相同的第三方，能够走同一个接口而不是各个业务系统对接。 不侵入业务系统，或者尽可能少的侵入。 所有第三方数据能汇聚到同一个数据库中，便于后续报表数据提取。 基于上面几点原因，我们决定开发一个专门的对接中心，负责对接上所有的第三方系统，内部系统只与对接中心对接。","text":"概述业务发展需要对接到多个三方系统，涉及到多项业务。内部有多条业务线，每条业务线都有对应的系统支撑。每个系统都需要对接一些第三方系统，在各个业务中会有一些重合。所以我们希望： 不同的业务线如果要对接相同的第三方，能够走同一个接口而不是各个业务系统对接。 不侵入业务系统，或者尽可能少的侵入。 所有第三方数据能汇聚到同一个数据库中，便于后续报表数据提取。 基于上面几点原因，我们决定开发一个专门的对接中心，负责对接上所有的第三方系统，内部系统只与对接中心对接。 # 架构设计","categories":[{"name":"项目实践","slug":"项目实践","permalink":"https://withoutcause.github.io/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/"}],"tags":[{"name":"架构","slug":"架构","permalink":"https://withoutcause.github.io/tags/%E6%9E%B6%E6%9E%84/"}]},{"title":"MongoDB慢查询分析","slug":"MongoDB慢查询分析","date":"2021-10-21T01:43:05.000Z","updated":"2021-10-21T01:43:05.000Z","comments":true,"path":"2021/10/21/MongoDB慢查询分析/","link":"","permalink":"https://withoutcause.github.io/2021/10/21/MongoDB%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%88%86%E6%9E%90/","excerpt":"MongoDB慢查询1db.system.profile.find() 输出结果如下：","text":"MongoDB慢查询1db.system.profile.find() 输出结果如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134&#123; &quot;op&quot;:&quot;query&quot;, #操作类型 &quot;ns&quot;:&quot;poseidon.business_order&quot;, #命名空间，db.collection &quot;command&quot;:&#123; #执行的命令 &quot;find&quot;:&quot;business_order&quot;, #操作的 collection &quot;filter&quot;:&#123; # 条件 &quot;bizSystemOrderId&quot;:&quot;1000342905&quot; &#125;, &quot;limit&quot;:&#123; &quot;$numberLong&quot;:&quot;10&quot; &#125;, &quot;shardVersion&quot;:[ &#123; &quot;$timestamp&quot;:&#123; &quot;t&quot;:40, &quot;i&quot;:1 &#125; &#125;, &#123; &quot;$oid&quot;:&quot;5ef1ec758f212cb90e379041&quot; &#125; ], &quot;lsid&quot;:&#123; &quot;id&quot;:&#123; &quot;$binary&quot;:&quot;6R/soj3ZQIGvvv0MWauOAw==&quot;, &quot;$type&quot;:&quot;04&quot; &#125;, &quot;uid&quot;:&#123; &quot;$binary&quot;:&quot;Y5mrDaxi8gv8RmdTsQ+1j7fmkr7JUsabhNmXAheU0fg=&quot;, &quot;$type&quot;:&quot;00&quot; &#125; &#125;, &quot;$clusterTime&quot;:&#123; &quot;clusterTime&quot;:&#123; &quot;$timestamp&quot;:&#123; &quot;t&quot;:1634720101, &quot;i&quot;:28 &#125; &#125;, &quot;signature&quot;:&#123; &quot;hash&quot;:&#123; &quot;$binary&quot;:&quot;QIX3+Td22GwnDi+ln7RP16nt0o8=&quot;, &quot;$type&quot;:&quot;00&quot; &#125;, &quot;keyId&quot;:&#123; &quot;$numberLong&quot;:&quot;6990046543956934658&quot; &#125; &#125; &#125;, &quot;$client&quot;:&#123; &quot;driver&quot;:&#123; &quot;name&quot;:&quot;PyMongo&quot;, &quot;version&quot;:&quot;3.8.0&quot; &#125;, &quot;os&quot;:&#123; &quot;type&quot;:&quot;Linux&quot;, &quot;name&quot;:&quot;Linux&quot;, &quot;architecture&quot;:&quot;x86_64&quot;, &quot;version&quot;:&quot;3.10.0-693.2.2.el7.x86_64&quot; &#125;, &quot;platform&quot;:&quot;CPython 3.6.5.final.0&quot;, &quot;mongos&quot;:&#123; &quot;host&quot;:&quot;g54g16057.cloud.cm3:3172&quot;, &quot;client&quot;:&quot;10.80.239.136:52694&quot;, &quot;version&quot;:&quot;4.0.13&quot; &#125; &#125;, &quot;$configServerState&quot;:&#123; &quot;opTime&quot;:&#123; &quot;ts&quot;:&#123; &quot;$timestamp&quot;:&#123; &quot;t&quot;:1634720099, &quot;i&quot;:1 &#125; &#125;, &quot;t&quot;:&#123; &quot;$numberLong&quot;:&quot;1&quot; &#125; &#125; &#125;, &quot;$db&quot;:&quot;poseidon&quot; &#125;, &quot;keysExamined&quot;:0, &quot;docsExamined&quot;:470765, &quot;cursorExhausted&quot;:true, &quot;numYield&quot;:3677, &quot;nreturned&quot;:0, &quot;locks&quot;:&#123; #锁信息 &quot;Global&quot;:&#123; &quot;acquireCount&quot;:&#123; &quot;r&quot;:&#123; &quot;$numberLong&quot;:&quot;3680&quot; &#125; &#125; &#125;, &quot;Database&quot;:&#123; &quot;acquireCount&quot;:&#123; &quot;r&quot;:&#123; &quot;$numberLong&quot;:&quot;3678&quot; &#125; &#125; &#125;, &quot;Collection&quot;:&#123; &quot;acquireCount&quot;:&#123; &quot;r&quot;:&#123; &quot;$numberLong&quot;:&quot;3678&quot; &#125; &#125; &#125; &#125;, &quot;storage&quot;:&#123; #存储信息 &quot;data&quot;:&#123; &quot;bytesRead&quot;:&#123; &quot;$numberLong&quot;:&quot;478045859&quot; #从磁盘放到缓存的字节数 &#125;, &quot;timeReadingMicros&quot;:&#123; &quot;$numberLong&quot;:&quot;507960&quot; #操作花费的时间，单位:微秒 &#125; &#125;, &quot;timeWaitingMicros&quot;:&#123; &quot;cache&quot;:&#123; &quot;$numberLong&quot;:&quot;8&quot; &#125; &#125; &#125;, &quot;responseLength&quot;:407, #返回的文档长度，单位:字节 &quot;protocol&quot;:&quot;op_msg&quot;, #消息的协议 &quot;millis&quot;:943, #从 MongoDB 开始操作到结束耗费的时间 &quot;planSummary&quot;:&quot;COLLSCAN&quot;, #操作形式，COLLSCAN 用于集合扫描，IXSCAN 用于扫描索引键，FETCH 用于检索文档 &quot;replRole&quot;:&#123; &quot;stateStr&quot;:&quot;PRIMARY&quot;, &quot;_id&quot;:3 &#125;&#125;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://withoutcause.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MongoDB","slug":"数据库/MongoDB","permalink":"https://withoutcause.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MongoDB/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://withoutcause.github.io/tags/MongoDB/"}]},{"title":"自学React系列-08之TypeScript","slug":"自学React系列-08之TypeScript","date":"2021-10-12T14:10:11.000Z","updated":"2021-10-12T14:10:11.000Z","comments":true,"path":"2021/10/12/自学React系列-08之TypeScript/","link":"","permalink":"https://withoutcause.github.io/2021/10/12/%E8%87%AA%E5%AD%A6React%E7%B3%BB%E5%88%97-08%E4%B9%8BTypeScript/","excerpt":"数据类型 number string boolean null undefined symbol object：对象类型 any：可以表示任何类型，与 Java 中的 Object 类型一个含义 定义变量","text":"数据类型 number string boolean null undefined symbol object：对象类型 any：可以表示任何类型，与 Java 中的 Object 类型一个含义 定义变量 定义 string，单引号 &#39;&#39; 或者双引号 &quot;&quot; 1let a: string = &#x27;a&#x27;; // 定义 string 类型的变量 a let 和 const 都可以定义变量，区别在于 let 和 const 定义的变量作用域不同。 const 是全局，let 是局部。 定义模板字符串 1let a: string = `good $&#123;name&#125;`; 定义 number 1let num: number = 1.1; 定义数组 1let arr:number[] = [1,2,3,4]; 类型断言 向 let num: number = 1.1; 中的 : number 不是必须的， ts 会根据赋值的类型自动推断出变量的类型，也可以用下面的写法: 1let num = 1.1; 定义数组使用中括号定义数组 [] 1let arr: number[] = [1, 2, 3, 4, 5]; 泛型数组 1let arr: Array&lt;number&gt; = [1, 2, 3, 4, 5]; 定义函数普通参数参数数量确定，参数类型确定，返回值确定。 123function foo(a: string): string &#123; return a;&#125; 可选参数函数有多个参数，但是其中的某一个或某几个参数可以不传值 123function foo(a: string, b?: string): string &#123; return a;&#125; 上面的 b 可以不不传值 参数默认值函数参数为其设置默认值 123function foo(a: string, b: string = &#x27;b&#x27;): string &#123; retunr a + b;&#125; 上面的示例中，如果调用 foo 函数，且不对参数 b 传值的话，b 的默认值就是字符串b。 参数多类型函数参数类型不固定，但是只能是其中的一种或几种类型，比如参数 b 只能是 number 或者 string 两种类型中的一种，但具体是哪一种不确定。 123function foo(a: string|number): string|number &#123; return a;&#125; Interface(接口)接口可以定义对象的描述 接口可以定义一些抽象方法 类类实现接口","categories":[{"name":"ts","slug":"ts","permalink":"https://withoutcause.github.io/categories/ts/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://withoutcause.github.io/tags/TypeScript/"},{"name":"ts","slug":"ts","permalink":"https://withoutcause.github.io/tags/ts/"}]},{"title":"警钟长鸣~01之19年一次记录","slug":"警钟长鸣-01之19年一次记录","date":"2021-10-11T14:35:18.000Z","updated":"2021-10-11T14:35:18.000Z","comments":true,"path":"2021/10/11/警钟长鸣-01之19年一次记录/","link":"","permalink":"https://withoutcause.github.io/2021/10/11/%E8%AD%A6%E9%92%9F%E9%95%BF%E9%B8%A3-01%E4%B9%8B19%E5%B9%B4%E4%B8%80%E6%AC%A1%E8%AE%B0%E5%BD%95/","excerpt":"关于 6.14 日晚上上线客户价值的总结上线内容 客户价值定时任务 hotel-manger (门店后台)","text":"关于 6.14 日晚上上线客户价值的总结上线内容 客户价值定时任务 hotel-manger (门店后台) 涉及模块工程 pig-yd-service 数据库添加字段，后面字段没有被使用，已废弃该字段，但是没有及时从数据库中删除 其他开发 hotel-manager (门店后台) 上线前的准备 数据库脚本 合并代码(未及时合并到 master) 当时没有使用 git-flow 这种工作流的试试，将 master 分支合并到开发分支，然后用开发分支打包上线。 上线过程打包 git 合并 非常不顺利 事故原因 执行初始化方法第一次 404 。原因是没有将代码合并到 master 分支，重新合并分支并上线。 执行初始化接口第二次失败，原因是有一条异常数据。 docker 上没有日志，没有将日志打印到控制台上 执行任务中途报错，有两个字段在测试环境中添加的后来废弃不使用了，生产环境数据库中没有这两个字段， SQL 执行报错。修改代码，从 Mybatis 配置文件和 Entity 对象中删除这两个字段的映射 执行任务中途报错，数据库中有 meal_type_name 数据异常，值为午餐但是后面有很多空格，整个字段长度超过新建表中定义的长度。 在代码中取该字段值的地方加上 trim() 方法 打开门店后台页面，有一个接口报错，原因是有两个字段在测试环境下添加废弃后未删除，被映射进了 Mybatis 的 xml 和 Entity 对象中，查询时报 Unknown cloumn &#39;MAN_VIP_ID&#39; xxx 定时调度的任务不执行，原因是代码中的逻辑错误，导致 if 永远都为 false 123456LocalTime startTime1 = LocalTime.of(23, 0, 0);LocalTime startTime2 = LocalTime.of(8, 0, 0);LocalTime nowTime = LocalTime.now();if (nowTime.isAfter(startTime1) &amp;&amp; nowTime.isBefore(startTime2)) &#123; xxxx&#125; 总结分析开发阶段 开发阶段需求不够明确，基本都是似是而非。重述时，不能完成的讲出来每个字段的取值逻辑，只是能够听懂。 规避，开会说明需求后，还要自己再仔细过一遍，对于每个计算字段是如何由来的，必须做到自己能够讲清楚，对于涉及到的表，必须要知道。 开发前，对异常状态考虑不够周全，写出的代码健壮性不够。 对所有数据都要认为不可靠，包含输入的和数据库中查到的，必须进行一次校验 考虑到如果系统发生故障，再重新恢复后的情况 如果是定时任务，任务本身要可控，可停，可启 要做幂等，如果是定时任务，同一个任务，多次执行结果应该是一样 代码执行过程要有日志，可以看到执行的痕迹，并且执行出错后可恢复 代码执行的最大时间要可控，不能出现超长执行，定时任务，一家酒店的数据执行时间长达 30 分钟是不正确的。 数据库查询，要考虑到上游的数据会持续增长，单次的查询量要固定或者控制在一个阈值之内，量大的时候多次去查询 插入数据，数据库数据可观察，避免出现大事务提交的情况 尽可能使用多线程处理，以提高性能 业务理解 充分理解需求，能够说清楚需求中每项数据的来源和流向，同时也能向别人讲述清楚，反复同产品确认 清楚受众，功能提供给谁，在什么场景下使用 对其他模块/系统是否存在影响 现有表结构有无修改字段名称、类型、长度等 现有表是否有删除/添加字段 如果是新建表，表中数据是否要与其他现有表数据同步变动 数据库中数据的来源是否有多处，其他模块/系统需要增加插入到新库的代码 新建表中数据增加，是否需要往其他表中插入数据 保持质疑，如果觉得某个做法有不合理，及时提出 编码 使用合适的数据类型， Entity 中不使用基本类型 对数据所有的来源都认为不可靠，需要做判断 代码要做健壮性判断，宁可多写 if (xxx != null) 字符串考虑空格的问题，要去除前后空格 判断的逻辑，测试时，要把 true 与 false 都覆盖到，不能只测单个可能 边界值，在做除法操作时，除数不能为 0，乘法时也要考虑 * 0 的情况 有浮点数(小数)时，要考虑到精度问题，以及取舍方式。 在 2021-10-11 无意中再翻到的，发现之前记的一些东西现在做得也并不是那么好。","categories":[{"name":"心得","slug":"心得","permalink":"https://withoutcause.github.io/categories/%E5%BF%83%E5%BE%97/"}],"tags":[{"name":"经验","slug":"经验","permalink":"https://withoutcause.github.io/tags/%E7%BB%8F%E9%AA%8C/"},{"name":"心得","slug":"心得","permalink":"https://withoutcause.github.io/tags/%E5%BF%83%E5%BE%97/"}]},{"title":"自学React系列~07之Redux","slug":"自学React系列-07之Redux","date":"2021-09-30T09:24:35.000Z","updated":"2021-09-30T09:24:35.000Z","comments":true,"path":"2021/09/30/自学React系列-07之Redux/","link":"","permalink":"https://withoutcause.github.io/2021/09/30/%E8%87%AA%E5%AD%A6React%E7%B3%BB%E5%88%97-07%E4%B9%8BRedux/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"自学React系列~06之路由","slug":"自学React系列-06之路由","date":"2021-09-18T16:06:02.000Z","updated":"2021-09-18T16:06:02.000Z","comments":true,"path":"2021/09/19/自学React系列-06之路由/","link":"","permalink":"https://withoutcause.github.io/2021/09/19/%E8%87%AA%E5%AD%A6React%E7%B3%BB%E5%88%97-06%E4%B9%8B%E8%B7%AF%E7%94%B1/","excerpt":"路由简介React 中的路由可以理解为：根据浏览器中的 URL 匹配对应的资源。需要用到路由最常见的场景就是导航，根据不同的 url 展示不同的页面。 在 React 中，路由需要使用到两个组件 Router 和 Route ，其中一个 Route 包含多个 Router 组件 。结构如下：","text":"路由简介React 中的路由可以理解为：根据浏览器中的 URL 匹配对应的资源。需要用到路由最常见的场景就是导航，根据不同的 url 展示不同的页面。 在 React 中，路由需要使用到两个组件 Router 和 Route ，其中一个 Route 包含多个 Router 组件 。结构如下： 1234&lt;Router&gt; &lt;Route path=&quot;/&quot; component=&#123;APP&#125;/&gt; &lt;Route path=&quot;/index&quot; component=&#123;Index&#125; /&gt;&lt;/Router&gt; path: 指定匹配的路径。component: 指定渲染的组件。安装组件: npm install react-router-dom RouterBrowserRouterBrowserRotuer ：从 url 地址栏中观察，是 url 会改着一起变化的。例如： https://shijieling.top/page/1 -&gt; https://shijieling.top/page/2 参数变化会在域名后面的 url 变化。 HashRouterHashRouter: url 地址栏中观察 ，前面的域名部分不会发生变化，而在在后面添加一个 # 号，然后再是路径信息 https://shijieling.top/#/page/1 -&gt; https://shijieling.top/#/page/2 Link和NavLinkLinkNavLink","categories":[{"name":"React","slug":"React","permalink":"https://withoutcause.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://withoutcause.github.io/tags/React/"}]},{"title":"自学React系列~05之axios","slug":"自学React系列-05之axios","date":"2021-09-16T14:39:09.000Z","updated":"2021-09-16T14:39:09.000Z","comments":true,"path":"2021/09/16/自学React系列-05之axios/","link":"","permalink":"https://withoutcause.github.io/2021/09/16/%E8%87%AA%E5%AD%A6React%E7%B3%BB%E5%88%97-05%E4%B9%8Baxios/","excerpt":"axios简介axios 是一个 JavaSctipt 的 http 客户端请求工具，同时也支持 Node.js 。axios 有以下特性： 向浏览器发送异步请求(ajax请求)。 支持 Promise API。 可以对请求(request) 和 响应(response)进行拦截。 可以将请求数据(request data) 和响应数据(response data)进行转换。 支持取消请求。 自动转换为 JSON 数据。 支持多种浏览器：Chrome、FireFox、Safari、MicroSoft Edge、IE11(基本没人使用)","text":"axios简介axios 是一个 JavaSctipt 的 http 客户端请求工具，同时也支持 Node.js 。axios 有以下特性： 向浏览器发送异步请求(ajax请求)。 支持 Promise API。 可以对请求(request) 和 响应(response)进行拦截。 可以将请求数据(request data) 和响应数据(response data)进行转换。 支持取消请求。 自动转换为 JSON 数据。 支持多种浏览器：Chrome、FireFox、Safari、MicroSoft Edge、IE11(基本没人使用) 发送GET请求12345678910111213let url = &#x27;http://localhost:8080/test/test&#x27;;axios.get(url) .then(function (response) &#123; // 处理成功情况 console.log(response);&#125;) .catch(function (error) &#123; // 处理错误情况 console.log(error);&#125;) .then(function () &#123; // 总是会执行&#125;); 发送POST请求123456789101112131415let url = &#x27;http://localhost:8080/test/test&#x27;;axios.post(url, &#123; // 这里是参数&#125;) .then(function (response) &#123; // 处理成功情况 console.log(response);&#125;) .catch(function (error) &#123; // 处理错误情况 console.log(error);&#125;) .then(function () &#123; // 总是会执行&#125;); 看起来只是简单的将 get 替换成 post 即可。 axios支持的请求方式 axios.request(config) axios.get(url[, config]) axios.post(url[, data[, config]]) axios.delete(url[, config]) axios.head(url[, config]) axios.options(url[, config]) axios.put(url[, data[, config]]) axios.patch(url[, data[, config]]) 创建axios实例12345const instance = axios.create(&#123; baseURL: &#x27;https://some-domain.com/api/&#x27;, timeout: 1000, headers: &#123;&#x27;X-Custom-Header&#x27;: &#x27;foobar&#x27;&#125;&#125;); 支持的配置参数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161&#123; // `url` 是用于请求的服务器 URL url: &#x27;/user&#x27;, // `method` 是创建请求时使用的方法 method: &#x27;get&#x27;, // 默认值，还可以写 psot，put，delete 等 // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。 // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL baseURL: &#x27;https://some-domain.com/api/&#x27;, // `transformRequest` 允许在向服务器发送前，修改请求数据 // 它只能用与 &#x27;PUT&#x27;, &#x27;POST&#x27; 和 &#x27;PATCH&#x27; 这几个请求方法 // 数组中最后一个函数必须返回一个字符串， 一个Buffer实例，ArrayBuffer，FormData，或 Stream // 你可以修改请求头。 transformRequest: [function (data, headers) &#123; // 对发送的 data 进行任意转换处理 return data; &#125;], // `transformResponse` 在传递给 then/catch 前，允许修改响应数据 transformResponse: [function (data) &#123; // 对接收的 data 进行任意转换处理 return data; &#125;], // 自定义请求头 headers: &#123;&#x27;X-Requested-With&#x27;: &#x27;XMLHttpRequest&#x27;&#125;, // `params` 是与请求一起发送的 URL 参数 // 必须是一个简单对象或 URLSearchParams 对象 params: &#123; ID: 12345 &#125;, // `paramsSerializer`是可选方法，主要用于序列化`params` // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/) paramsSerializer: function (params) &#123; return Qs.stringify(params, &#123;arrayFormat: &#x27;brackets&#x27;&#125;) &#125;, // `data` 是作为请求体被发送的数据 // 仅适用 &#x27;PUT&#x27;, &#x27;POST&#x27;, &#x27;DELETE 和 &#x27;PATCH&#x27; 请求方法 // 在没有设置 `transformRequest` 时，则必须是以下类型之一: // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams // - 浏览器专属: FormData, File, Blob // - Node 专属: Stream, Buffer data: &#123; firstName: &#x27;Fred&#x27; &#125;, // 发送请求体数据的可选语法 // 请求方式 post // 只有 value 会被发送，key 则不会 data: &#x27;Country=Brasil&amp;City=Belo Horizonte&#x27;, // `timeout` 指定请求超时的毫秒数。 // 如果请求时间超过 `timeout` 的值，则请求会被中断 timeout: 1000, // 默认值是 `0` (永不超时) // `withCredentials` 表示跨域请求时是否需要使用凭证 withCredentials: false, // default // `adapter` 允许自定义处理请求，这使测试更加容易。 // 返回一个 promise 并提供一个有效的响应 （参见 lib/adapters/README.md）。 adapter: function (config) &#123; /* ... */ &#125;, // `auth` HTTP Basic Auth auth: &#123; username: &#x27;janedoe&#x27;, password: &#x27;s00pers3cret&#x27; &#125;, // `responseType` 表示浏览器将要响应的数据类型 // 选项包括: &#x27;arraybuffer&#x27;, &#x27;document&#x27;, &#x27;json&#x27;, &#x27;text&#x27;, &#x27;stream&#x27; // 浏览器专属：&#x27;blob&#x27; responseType: &#x27;json&#x27;, // 默认值 // `responseEncoding` 表示用于解码响应的编码 (Node.js 专属) // 注意：忽略 `responseType` 的值为 &#x27;stream&#x27;，或者是客户端请求 // Note: Ignored for `responseType` of &#x27;stream&#x27; or client-side requests responseEncoding: &#x27;utf8&#x27;, // 默认值 // `xsrfCookieName` 是 xsrf token 的值，被用作 cookie 的名称 xsrfCookieName: &#x27;XSRF-TOKEN&#x27;, // 默认值 // `xsrfHeaderName` 是带有 xsrf token 值的http 请求头名称 xsrfHeaderName: &#x27;X-XSRF-TOKEN&#x27;, // 默认值 // `onUploadProgress` 允许为上传处理进度事件 // 浏览器专属 onUploadProgress: function (progressEvent) &#123; // 处理原生进度事件 &#125;, // `onDownloadProgress` 允许为下载处理进度事件 // 浏览器专属 onDownloadProgress: function (progressEvent) &#123; // 处理原生进度事件 &#125;, // `maxContentLength` 定义了node.js中允许的HTTP响应内容的最大字节数 maxContentLength: 2000, // `maxBodyLength`（仅Node）定义允许的http请求内容的最大字节数 maxBodyLength: 2000, // `validateStatus` 定义了对于给定的 HTTP状态码是 resolve 还是 reject promise。 // 如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)， // 则promise 将会 resolved，否则是 rejected。 validateStatus: function (status) &#123; return status &gt;= 200 &amp;&amp; status &lt; 300; // 默认值 &#125;, // `maxRedirects` 定义了在node.js中要遵循的最大重定向数。 // 如果设置为0，则不会进行重定向 maxRedirects: 5, // 默认值 // `socketPath` 定义了在node.js中使用的UNIX套接字。 // e.g. &#x27;/var/run/docker.sock&#x27; 发送请求到 docker 守护进程。 // 只能指定 `socketPath` 或 `proxy` 。 // 若都指定，这使用 `socketPath` 。 socketPath: null, // default // `httpAgent` and `httpsAgent` define a custom agent to be used when performing http // and https requests, respectively, in node.js. This allows options to be added like // `keepAlive` that are not enabled by default. httpAgent: new http.Agent(&#123; keepAlive: true &#125;), httpsAgent: new https.Agent(&#123; keepAlive: true &#125;), // `proxy` 定义了代理服务器的主机名，端口和协议。 // 您可以使用常规的`http_proxy` 和 `https_proxy` 环境变量。 // 使用 `false` 可以禁用代理功能，同时环境变量也会被忽略。 // `auth`表示应使用HTTP Basic auth连接到代理，并且提供凭据。 // 这将设置一个 `Proxy-Authorization` 请求头，它会覆盖 `headers` 中已存在的自定义 `Proxy-Authorization` 请求头。 // 如果代理服务器使用 HTTPS，则必须设置 protocol 为`https` proxy: &#123; protocol: &#x27;https&#x27;, host: &#x27;127.0.0.1&#x27;, port: 9000, auth: &#123; username: &#x27;mikeymike&#x27;, password: &#x27;rapunz3l&#x27; &#125; &#125;, // see https://axios-http.com/zh/docs/cancellation cancelToken: new CancelToken(function (cancel) &#123; &#125;), // `decompress` indicates whether or not the response body should be decompressed // automatically. If set to `true` will also remove the &#x27;content-encoding&#x27; header // from the responses objects of all decompressed responses // - Node only (XHR cannot turn off decompression) decompress: true // 默认值&#125; 响应内容1234567891011121314151617181920212223&#123; // `data` 由服务器提供的响应 data: &#123;&#125;, // `status` 来自服务器响应的 HTTP 状态码 status: 200, // `statusText` 来自服务器响应的 HTTP 状态信息 statusText: &#x27;OK&#x27;, // `headers` 是服务器响应头 // 所有的 header 名称都是小写，而且可以使用方括号语法访问 // 例如: `response.headers[&#x27;content-type&#x27;]` headers: &#123;&#125;, // `config` 是 `axios` 请求的配置信息 config: &#123;&#125;, // `request` 是生成此响应的请求 // 在node.js中它是最后一个ClientRequest实例 (in redirects)， // 在浏览器中则是 XMLHttpRequest 实例 request: &#123;&#125;&#125; 如果是从后端取响应数据应该是 response.data 里面的内容。 设置全局参数1234axios.defaults.baseURL = &#x27;https://api.example.com&#x27;;axios.defaults.headers.common[&#x27;Authorization&#x27;] = AUTH_TOKEN;axios.defaults.headers.post[&#x27;Content-Type&#x27;] = &#x27;application/x-www-form-urlencoded&#x27;;// xxx 使用 axios.defaults.xxx 进行设置即可。 配置将会按优先级进行合并。它的顺序是：在 lib/defaults.js 中找到的库默认值，然后是实例的 defaults 属性，最后是请求的 config 参数。后面的优先级要高于前面的。 拦截器拦截器分为 请求拦截器 和 响应拦截器 两类，分别对请求和响应进行拦截。 请求拦截器1234567axios.interceptors.request.use(function (config) &#123; // 在发送请求之前做些什么 return config; &#125;, function (error) &#123; // 对请求错误做些什么 return Promise.reject(error); &#125;); 响应拦截器123456789axios.interceptors.response.use(function (response) &#123; // 2xx 范围内的状态码都会触发该函数。 // 对响应数据做点什么 return response; &#125;, function (error) &#123; // 超出 2xx 范围的状态码都会触发该函数。 // 对响应错误做点什么 return Promise.reject(error); &#125;); 移除拦截器1234// 这里定义拦截器const myInterceptor = axios.interceptors.request.use(function () &#123;/*...*/&#125;);// 这里将上面的拦截器移除axios.interceptors.request.eject(myInterceptor); 取消请求123456789101112const CancelToken = axios.CancelToken;let cancel;axios.get(&#x27;/user/12345&#x27;, &#123; cancelToken: new CancelToken(function executor(c) &#123; // executor 函数接收一个 cancel 函数作为参数 cancel = c; &#125;)&#125;);// 取消请求cancel(); 以上是 axios 的一些基本使用。","categories":[{"name":"React","slug":"React","permalink":"https://withoutcause.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://withoutcause.github.io/tags/React/"},{"name":"Ajax","slug":"Ajax","permalink":"https://withoutcause.github.io/tags/Ajax/"},{"name":"axios","slug":"axios","permalink":"https://withoutcause.github.io/tags/axios/"}]},{"title":"自学React系列~04之React脚手架","slug":"自学React系列-04之React脚手架","date":"2021-09-13T14:10:52.000Z","updated":"2021-09-13T14:10:52.000Z","comments":true,"path":"2021/09/13/自学React系列-04之React脚手架/","link":"","permalink":"https://withoutcause.github.io/2021/09/13/%E8%87%AA%E5%AD%A6React%E7%B3%BB%E5%88%97-04%E4%B9%8BReact%E8%84%9A%E6%89%8B%E6%9E%B6/","excerpt":"React脚手架安装全局安装 create-react-app 包 1sjl@sjldeMacBook-Pro ~ npm install -g create-react-app","text":"React脚手架安装全局安装 create-react-app 包 1sjl@sjldeMacBook-Pro ~ npm install -g create-react-app 切换到要创建前端工程的目录，使用 create-react-app 命令创建 react-test 工程 12cd /Users/sjl/work/other/react #进入目录create-react-app react-test # 使用 create-react-app 创建工程，工程名称为: react-test React脚手架目录结构 node_modules存放一些安装的依赖包 public存放一些静态资源 src源码文件夹，在很多其他语言的脚手架里也有这种名称。比如 Java 的 Maven 也有 src 目录。 .gitignoregit 的忽略配置(非必须)，可以删除。 package.jsonnode的包文件、项目的结束 README.md一般写一些简介，仅阅读用 yarn.lock项目依赖的安装包 运行脚手架在终端窗口进入工程所在的目录，执行下面命令 1yarn start 终端输出 页面展示","categories":[{"name":"React","slug":"React","permalink":"https://withoutcause.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://withoutcause.github.io/tags/React/"}]},{"title":"自学React系列~03之组件的生命周期","slug":"自学React系列-03之组件的生命周期","date":"2021-09-12T09:56:36.000Z","updated":"2021-09-12T09:56:36.000Z","comments":true,"path":"2021/09/12/自学React系列-03之组件的生命周期/","link":"","permalink":"https://withoutcause.github.io/2021/09/12/%E8%87%AA%E5%AD%A6React%E7%B3%BB%E5%88%97-03%E4%B9%8B%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","excerpt":"组件的生命周期组件的生命周期主要包含三个阶段，分别是：**挂载阶段(mount)、更新阶段(update)、卸载阶段(unmount)**。","text":"组件的生命周期组件的生命周期主要包含三个阶段，分别是：**挂载阶段(mount)、更新阶段(update)、卸载阶段(unmount)**。 挂载阶段半截阶段主要调用的方法如下: constructor()：构造函数，类(组件)在创建时会调用该函数，作用阶段在 render 之前调用。 static getDerivedStateFromProps()：这个方法基本不使用。 render()：组件的渲染 componentDidMount()：组件渲染完成，组件组装到 DOM 上之后调用该函数，作用阶段在 render 之后调用。 更新阶段 static getDerivedStateFromProps()：这个方法基本不使用。 shouldComponentUpdate()：返回一个布尔值，返回结果决定是否继续渲染组件。 render() ：与挂载阶段一，渲染组件。一般在调用 setState() 函数时会触发界面的重新渲染。 getSnapshotBeforeUpdate()：在最近一次渲染输出（提交到 DOM 节点）之前调用。它使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置），该函数用得极少。 componentDiaUpdate()：当组件更新后调用该函数。注意:首次渲染不会调用该函数。 卸载阶段 componentWillUnmount()：在组件卸载之前调用。在该函数中不要调用 setState() 这类会触发组件渲染的方法，因为该组件永远不会再渲染了。 对于有编程基础的人来说，生命周期理解起来很简单。在某个特殊阶段做点特殊的事情，我们就需要生命周期。","categories":[{"name":"React","slug":"React","permalink":"https://withoutcause.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://withoutcause.github.io/tags/React/"}]},{"title":"自学React系列~02之类组件三大属性","slug":"自学React系列-02之类组件三大属性","date":"2021-09-09T14:23:54.000Z","updated":"2021-09-09T14:23:54.000Z","comments":true,"path":"2021/09/09/自学React系列-02之类组件三大属性/","link":"","permalink":"https://withoutcause.github.io/2021/09/09/%E8%87%AA%E5%AD%A6React%E7%B3%BB%E5%88%97-02%E4%B9%8B%E7%B1%BB%E7%BB%84%E4%BB%B6%E4%B8%89%E5%A4%A7%E5%B1%9E%E6%80%A7/","excerpt":"state每个类组件上都有 state 属性，state属性表示对应组件的状态。state 的使用如下: 1234567891011121314151617181920class Person extends React.Component &#123; constructor(props)&#123; super(props); this.state = &#123;hide: false&#125; this.modifyName = this.modifyName.bind(this); &#125; render()&#123; /* * 1. onClinck 不能写 onclick , React 封装过的点击事件，不是 html 的点击事件 * 2.不能写 modifyName() 这种形式 */ return &lt;h1 onClick=&#123;this.modifyName&#125;&gt;我的名字叫&#123;this.state.hide ? &#x27;张三&#x27;: &#x27;***&#x27;&#125;&lt;/h1&gt;; &#125; modifyName()&#123; const hide = this.state.hide; this.setState(&#123;hide: !hide&#125;) &#125;&#125;","text":"state每个类组件上都有 state 属性，state属性表示对应组件的状态。state 的使用如下: 1234567891011121314151617181920class Person extends React.Component &#123; constructor(props)&#123; super(props); this.state = &#123;hide: false&#125; this.modifyName = this.modifyName.bind(this); &#125; render()&#123; /* * 1. onClinck 不能写 onclick , React 封装过的点击事件，不是 html 的点击事件 * 2.不能写 modifyName() 这种形式 */ return &lt;h1 onClick=&#123;this.modifyName&#125;&gt;我的名字叫&#123;this.state.hide ? &#x27;张三&#x27;: &#x27;***&#x27;&#125;&lt;/h1&gt;; &#125; modifyName()&#123; const hide = this.state.hide; this.setState(&#123;hide: !hide&#125;) &#125;&#125; 简略的写法 12345678910111213141516class Person extends React.Component &#123; this.state = &#123;hide: false&#125; render()&#123; /* * 1. onClinck 不写 onclick , React 封装过的点击事件，不是 html 的点击事件 * 2.不能写 modifyName() 这种形式 */ return &lt;h1 onClick=&#123;this.modifyName&#125;&gt;我的名字叫&#123;this.state.hide ? &#x27;张三&#x27;: &#x27;***&#x27;&#125;&lt;/h1&gt;; &#125; modifyName = () =&gt;&#123; const hidd = this.state.hide; // 这里一定要调用 this.setState() 方法重新设置状态，而不能使用 this.state.hide = true 的形式。 this.setState(&#123;hide: !hide&#125;) &#125;&#125; 注意点: onClinck 不能写 onclick , React 封装过的点击事件，不是 html 的点击事件。React 中的事件与 html 中的不一样。 注册事件时不能写 modifyName() 这种形式，不能直接调用函数。 一定要调用 this.setState() 方法重新设置状态，而不能使用 this.state.hide = true 的形式。 propsprops 用于接收组件传递的参数。 props 属性是只读的。 props 可以设置默认值，也可以对类型进行验证(验证不通过在控制台有警告信息)。 通过组件参数传值，在 props 中接收组件传的属性值 12345678class Demo extends React.Component &#123; render() &#123; console.log(this); return &lt;h2&gt;我是&#123;this.props.name&#125;&lt;/h2&gt;; &#125;&#125;ReactDOM.render(&lt;Demo name=&#x27;李四&#x27;&gt;&lt;/Demo&gt;, document.getElementById(&quot;props&quot;)); 设置默认值 123456789101112class Demo extends React.Component &#123; static defaultProps = &#123; name: &#x27;***&#x27; &#125; render() &#123; console.log(this); return &lt;h2&gt;我是&#123;this.props.name&#125;&lt;/h2&gt;; &#125;&#125;ReactDOM.render(&lt;Demo&gt;&lt;/Demo&gt;, document.getElementById(&quot;props&quot;)); 类型校验 校验需要额外引入一个库 prop-types.js 1234567891011121314151617class Demo extends React.Component &#123; // 设置默认值为 *** static defaultProps = &#123; name: &#x27;***&#x27; &#125; // 校验 name 的类型为 Number static propTypes = &#123; name: PropTypes.number &#125; render() &#123; console.log(this); return &lt;h2&gt;我是&#123;this.props.name&#125;&lt;/h2&gt;; &#125;&#125;ReactDOM.render(&lt;Demo&gt;&lt;/Demo&gt;, document.getElementById(&quot;props&quot;)); 在浏览器的控制台会有一条警告信息，不过浏览器还是会将 *** 显示出来 12Warning: Failed prop type: Invalid prop `name` of type `string` supplied to `Demo`, expected `number`. at Demo (&lt;anonymous&gt;:15:9) refsRef 转发是一项将 ref 自动地通过组件传递到其一子组件的技巧。 字符串的形式 字符串方式是最简单的一种试，但是官方已经不推荐使用。 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;类组件之refs&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;test&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/babel&quot;&gt; class RefDemo extends React.Component &#123; constructor(props)&#123; super(props); &#125; handleSubmit = (event) =&gt; &#123; event.preventDefault(); alert(this.refs.demo.value) &#125; render() &#123; console.log(this); return ( &lt;div&gt; &lt;form&gt; &lt;input ref=&#x27;demo&#x27; type=&#x27;text&#x27;/&gt; &lt;button onClick=&#123;this.handleSubmit&#125;&gt;提交&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; ); &#125; &#125; ReactDOM.render(&lt;RefDemo/&gt;, document.getElementById(&quot;test&quot;)); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 回调函数的形式 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;类组件之回调函数refs&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;test&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/babel&quot;&gt; class RefDemo extends React.Component &#123; handleSubmit = (event) =&gt; &#123; event.preventDefault(); console.log(this); alert(this.element.value) &#125; render() &#123; return ( &lt;div&gt; &lt;form&gt; &lt;input ref=&#123;node =&gt; this.element=node&#125; type=&#x27;text&#x27;/&gt; &lt;button onClick=&#123;this.handleSubmit&#125;&gt;提交&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; ); &#125; &#125; ReactDOM.render(&lt;RefDemo/&gt;, document.getElementById(&quot;test&quot;)); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 创建Refs 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;类组件之创建refs&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;test&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/babel&quot;&gt; class RefDemo extends React.Component &#123; constructor(props)&#123; super(props) this.currentRef = React.createRef(); &#125; handleSubmit = (event) =&gt; &#123; event.preventDefault(); const element = this.currentRef.current; alert(this.element.value) &#125; render() &#123; return ( &lt;div&gt; &lt;form&gt; &lt;input ref=&#123;node =&gt; this.element=node&#125; type=&#x27;text&#x27;/&gt; &lt;button onClick=&#123;this.handleSubmit&#125;&gt;提交&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; ); &#125; &#125; ReactDOM.render(&lt;RefDemo/&gt;, document.getElementById(&quot;test&quot;)); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 非受控组件表单数据将交由 DOM 节点来处理，非 React 处理。 受控组件在 HTML 中，表单元素（如&lt;input&gt;、 &lt;textarea&gt; 和 &lt;select&gt;）之类的表单元素通常自己维护 state，并根据用户输入进行更新。而在 React 中，可变状态（mutable state）通常保存在组件的 state 属性中，并且只能通过使用 setState()来更新。 我们可以把两者结合起来，使 React 的 state 成为“唯一数据源”。渲染表单的 React 组件还控制着用户输入过程中表单发生的操作。被 React 以这种方式控制取值的表单输入元素就叫做“受控组件”。","categories":[{"name":"React","slug":"React","permalink":"https://withoutcause.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://withoutcause.github.io/tags/React/"}]},{"title":"自学React系列~01之React基础","slug":"自学React系列-01之React基础","date":"2021-09-08T14:40:01.000Z","updated":"2021-09-08T14:40:01.000Z","comments":true,"path":"2021/09/08/自学React系列-01之React基础/","link":"","permalink":"https://withoutcause.github.io/2021/09/08/%E8%87%AA%E5%AD%A6React%E7%B3%BB%E5%88%97-01%E4%B9%8BReact%E5%9F%BA%E7%A1%80/","excerpt":"React的HelloWorld使用任何语言都先来一个 HelloWorld 。 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;test&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/babel&quot;&gt; const VDOM = &lt;h1&gt;Hello React!&lt;/h1&gt;; ReactDOM.render(VDOM, document.getElementById(&quot;test&quot;)); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","text":"React的HelloWorld使用任何语言都先来一个 HelloWorld 。 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;test&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/babel&quot;&gt; const VDOM = &lt;h1&gt;Hello React!&lt;/h1&gt;; ReactDOM.render(VDOM, document.getElementById(&quot;test&quot;)); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; JSX语法 定义虚拟 DOM 的时候不要写引号 1const VDOM = &lt;h1&gt;Hello React!&lt;/h1&gt;; #h1标签前后都没有引号 标签中混入 JS 表达式时要用 &#123;&#125; 123456789const arr = [&#x27;张三&#x27;, &#x27;李四&#x27;, &#x27;王二&#x27;];const VDOM = &lt;h4&gt; &lt;ul&gt; &#123;arr.map((key, i) =&gt; &#123; return &lt;li key=&#123;i&#125;&gt;&#123;key&#125;&lt;/li&gt;; # 这里的 key 使用 &#123;&#125; 包起来的 &#125;)&#125; &lt;/ul&gt; &lt;/h4&gt;;ReactDOM.render(VDOM, document.getElementById(&quot;test&quot;)); 使用样式时，类名不要用 class 而要用 className 1const VDOM = &lt;h1 className=&#x27;title&#x27;&gt;Hello React!&lt;/h1&gt;; #使用定义的 .title css 样式 内联样式，使用 style 属性时要用 &#123;&#123;style: value&#125;&#125;，如果有样式是 background-color 这种的改写成坨峰形式即 backgroundColor 1const VDOM = &lt;h1 style=&#123;&#123;&#x27;backgroundColor&#x27;: &#x27;pink&#x27;, &#x27;width&#x27;: &#x27;1000px&#x27;, &#x27;height&#x27;: &#x27;100px&#x27;&#125;&#125;&gt;Hello React!&lt;/h1&gt;; 只有一个顶级标签(要标签) 1const VDOM = &lt;h1 className=&#x27;title&#x27;&gt;Hello React!&lt;/h1&gt;; #不能再出现 与 &lt;h1&gt; 标签平级的标签了 标签必须闭合 1const VDOM = &lt;h1&gt;; #这种形式不可以 标签首字母小写会转为同名的 html 标签 1const VDOM = &lt;h1&gt;Hello React&lt;/h1&gt;; #会转换成 html 的 &lt;h1&gt;&lt;/h1&gt; 标签 标签首字母大写代表是 React 的组件 12345function Demo()&#123; return &lt;h1&gt;这是一个函数式组件&lt;/h1&gt;;&#125;ReactDOM.render(&lt;Demo/&gt;, document.getElementById(&quot;test&quot;)); #&lt;Demo/&gt;标签就是 React 的组件 React组件函数式组件使用函数定义的 React 组件称为函数组件，示例如下: 1234function Demo()&#123; return &lt;h1&gt;这是一个函数式组件&lt;/h1&gt;;&#125;ReactDOM.render(&lt;Demo&gt;&lt;/Demo&gt;, document.getElementById(&quot;FunctionComponent&quot;)); 类式组件使用类定义的React组件称为类式组件，示例如下: 123456class ClassComponent extends React.Component &#123; render()&#123; return &lt;h1&gt;这是类组件&lt;/h1&gt;; &#125;&#125;ReactDOM.render(&lt;ClassComponent&gt;&lt;/ClassComponent&gt;, document.getElementById(&quot;ClassComponent&quot;));","categories":[{"name":"React","slug":"React","permalink":"https://withoutcause.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://withoutcause.github.io/tags/React/"}]},{"title":"自学React系列~00之目录","slug":"自学React系列-00之目录","date":"2021-09-08T14:24:38.000Z","updated":"2021-09-08T14:24:38.000Z","comments":true,"path":"2021/09/08/自学React系列-00之目录/","link":"","permalink":"https://withoutcause.github.io/2021/09/08/%E8%87%AA%E5%AD%A6React%E7%B3%BB%E5%88%97-00%E4%B9%8B%E7%9B%AE%E5%BD%95/","excerpt":"前言我为什么要学 React之前一直计划着和朋友一起开发一款基于 Netty 的推送系统，当时的计划是支持 WebSocket 的推送，很无奈我和他都是后端，这就导致 没有人做前端的工作。此时我就想着，自己能不能也学下前端，自己来开发。","text":"前言我为什么要学 React之前一直计划着和朋友一起开发一款基于 Netty 的推送系统，当时的计划是支持 WebSocket 的推送，很无奈我和他都是后端，这就导致 没有人做前端的工作。此时我就想着，自己能不能也学下前端，自己来开发。 在刚刚工作的时候，其实是前后端混合着写的。前端是 JSP + JQuery，后端是 Spring + Mybatis。那时候的前端都是 Ajax 发起请求，现在变化很快前端也开始讲究工程化了。刚入行的时候都能做前端的工作，现在不能荒废了。 最近和同事聊天，有一句话直击心灵。在公司写代码，写出的业务代码是公司的。即使公司业务发展得再好，个人付出了再多最后还剩什么呢。工资？那是应得的部分。技术？只有业务代码。经验？技术经验还可以用得上，如果是业务经验呢，毫无用处。什么才是自己的，我思考了很久。如果自己利用会的技术，做出的具有一定能用性的作品，这才是自己的。这时就要求个人是全栈的，光后端可不行。 React 我来了！！！ 目录自学React系列-01之React基础 自学React系列-02之类组件三大属性 自学React系列-03之组件的生命周期 自学React系列-04之React脚手架 自学React系列-05之axios 自学React系列-06之路由 … 更新中…","categories":[{"name":"React","slug":"React","permalink":"https://withoutcause.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://withoutcause.github.io/tags/React/"}]},{"title":"自学k8s系列~06之滚动更新","slug":"自学k8s系列-06之滚动更新","date":"2021-09-04T14:46:37.000Z","updated":"2021-09-04T14:46:37.000Z","comments":true,"path":"2021/09/04/自学k8s系列-06之滚动更新/","link":"","permalink":"https://withoutcause.github.io/2021/09/04/%E8%87%AA%E5%AD%A6k8s%E7%B3%BB%E5%88%97-06%E4%B9%8B%E6%BB%9A%E5%8A%A8%E6%9B%B4%E6%96%B0/","excerpt":"Pod健康检查与服务可用性检查Kubenetes 对 Pod 的健康检查可用两类探针来进行检查: LivenessProbe 和 ReadinessProbe 。 LivenessProbe","text":"Pod健康检查与服务可用性检查Kubenetes 对 Pod 的健康检查可用两类探针来进行检查: LivenessProbe 和 ReadinessProbe 。 LivenessProbe判断容器是否存活，主要是对 Running 状态进行检测，如果检测到不健康，则将该容器杀掉然后根据容器的重启策略做相应的处理。如果容器没有指定 LivenessProbe 探针，则 kubelet 认为该容器永远是健康的。 ReadinessProbeReadinessProbe 探针主要用于判断容器服务是否可用，即是否处于(Ready状态)。达到 Ready 状态的 Pod 才可以接收请求，如果容器不是 Ready 状态则自动将该容器从 Service 的 Endpoing 列表中隔离出去。当容器恢复到 Ready 状态时，再将容器加入到 Endping 列表中。这样就能保证容器如果没有处于 Ready 状态就不会有流量请求到该 Pod 上。 探针实现方式LivenessProbe 和 ReadinessProbe 都可以配置以下三种实现方式和自定义扩展的方式。 ExecAction在容器内部执行一个命令，如果该命令返回码为 0 ，则标志着该容器健康。 12345678910111213141516171819202122apiVersion: v1kind: Podmetadata: name: liveness labels: name: livenessspec: containers: - name: liveness image: busybox args: - /bin/sh - -c - echo ok &gt; /tmp/headlth; sleep 10; rm -rf /tmp/health; sleep 600 livenessProbe: exec: command: - cat - /tmp/health initialDelaySeconds: 15 timeoutSeconds: 1 创建了一个文件位于 /tmp 目录下，10 秒后将期删除，然后探针去检测该文件。该 Pod 会被判断为不健康，执行多次重启。 123kubectl get pod livenessNAME READY STATUS RESTARTS AGEliveness 1/1 Running 2 2m30s TCPSocketAction通过容器的 IP 地址和端口号执行 TCP 检查，如果能够建立 TCP 链接，则表明容器健康。 12345678910111213141516171819202122apiVersion: v1kind: Podmetadata: name: goproxy labels: app: goproxyspec: containers: - name: goproxy image: snail007/goproxy ports: - containerPort: 8080 readinessProbe: tcpSocket: port: 8080 initialDelaySeconds: 5 periodSeconds: 10 livenessProbe: tcpSocket: port: 8080 initialDelaySeconds: 15 periodSeconds: 20 通过 RESTARTS 可以查看到重启的次数 12345kubectl get podsNAME READY STATUS RESTARTS AGEgoproxy 0/1 CrashLoopBackOff 3 93swebapp-f2ckt 1/1 Running 1 24hwebapp-wsllj 1/1 Running 1 24h HTTPGetAction通过容器的 IP 地址、端口号及路径调用 HTTP GET 方法，如果响应码(HttpStatusCode) 大于等于 200 且小于 400，则表明容器健康。 123456789101112131415161718apiVersion: v1kind: Podmetadata: name: nginx labels: app: nginxspec: containers: - name: nginx image: nginx ports: - containerPort: 80 livenessProbe: httpGet: path: /healthz port: 80 initialDelaySeconds: 15 periodSeconds: 20 Pod的升级Pod 升级时，使用 kubectl edit xxx.yaml ，将自动进行 Pod 升级操作。升级过程如下: 先创建一个新的 ReplicaSet ，将副本设为1. 老的 ReplicaSet 副本缩减1. 重复以上过程 升级策略 重建(Recreate): 设置 spec.strategy.type=Recreate 。在创建 Pod 的时候会先杀掉所有正在运行的 Pod ，然后创建新的 Pod 滚动更新(RollingUpdate): 设置 spec.strategy.type=RollingUpdate 。Deployment 会以滚动更新的方式来逐个更新 Pod ，配合参数 spec.strategy.type.RollingUpdate.maxUnavailabel 和 spec.strategy.type.RollingUpdate.maxSurge 可以控制滚动更新的过程。 Pod的回滚Pod的扩缩容Pod 的扩缩容其实就是维持 Pod 的数量，当 Pod 数量增加是就是扩容,当 Pod 数量减少时就是缩容。扩缩容有手动和自动两种方式。 手动扩缩容：手动的去调整 pod 的数量。通过 --replicas 指定 Pod 的数量，也可以在 yaml 文件中调整 spec.replicas 的值 自动扩缩容：使用者指定一些指标并指定 Pod 数量的范围，系统将在这个范围内自动调整 Pod 的数量。 手动扩缩容 命令方式 1kubectl scale deployment pod_name -- replicas podNumber #通过指定 --replicase 来指定 pod 数量完成扩缩容 yaml 方式 1234567891011121314151617181920212223apiVersion: apps/v1kind: Deploymentmetadata: name: scalespec: replicas: 3 #指定 Pod 副本数 selector: matchLabels: app: scale template: metadata: labels: app: scale spec: containers: - name: scale image: nginx resources: limits: memory: &quot;128Mi&quot; cpu: &quot;500m&quot; ports: - containerPort: 80 自动扩缩容自动扩缩容指标：Pod 资源使用率、Pod 自定义指标、Object 自定义指标或外部自定义指标。 \u0018todo 自动扩缩容目前暂时没有场景，不深入研究。 写在最后自学 k8s 系列，到这里我准备暂时告一段落了，等过三个月后再回来复习复习 k8s 的内容。2021-08-24开始学习 k8s 到今天 2021-09-07 也有 15 天时间，时间也不算长。当时学习 k8s 是因为现在 k8s 实在太火了，各种大会各路大牛几乎都在提 k8s ，这么火的东西我想要了解它到底是什么(应用层面^_^)。k8s 的基本概念和一些简单操作也算是入门了，在当前的工作中也没有这方面的应用场景，所以打算暂停了，同时为了避免自己学过的东西遗忘也定下了 3 个月后再回来复习的目标。 2021-12-07 开始回来复习 k8s 的内容。","categories":[{"name":"k8s","slug":"k8s","permalink":"https://withoutcause.github.io/categories/k8s/"}],"tags":[{"name":"k8s","slug":"k8s","permalink":"https://withoutcause.github.io/tags/k8s/"}]},{"title":"自学k8s系列~05之Service","slug":"自学k8s系列-05之Service","date":"2021-09-01T14:54:59.000Z","updated":"2021-09-01T14:54:59.000Z","comments":true,"path":"2021/09/01/自学k8s系列-05之Service/","link":"","permalink":"https://withoutcause.github.io/2021/09/01/%E8%87%AA%E5%AD%A6k8s%E7%B3%BB%E5%88%97-05%E4%B9%8BService/","excerpt":"Service作用 Service 通过 label 将 Pod 聚合起来。 为这一组 Pod 提供统一的访问入口(IP和域名)。 将访问的请求负载到 Pod 上。 Pod 是容器的载体本身是不稳定的，但是 Service 是稳定的。","text":"Service作用 Service 通过 label 将 Pod 聚合起来。 为这一组 Pod 提供统一的访问入口(IP和域名)。 将访问的请求负载到 Pod 上。 Pod 是容器的载体本身是不稳定的，但是 Service 是稳定的。 Service定义12345678910111213141516171819202122232425 apiVersion: v1 # Required kind: Service # Required metadata: # Required name: string # Required namespace: string # Required labels: - name: string annotations: - name: stringspec: # Required selector: [] # Required type: string # Required clusterIP: string sessionAffinity: string ports: - name: string protocol: string port: int targetPort: int nodePort: int status: loadBalancer: ingress: ip: string hostname: string Service的基本使用12345678910apiVersion: v1kind: Servicemetadata: name: webappspec: selector: app: webapp ports: - port: 8081 targetPort: 8081 kind 指定 Service ， selector 选择指定的 label ，会将 label 包含 app:web 的所有 Pod 都加到这个 Service 中来。 1kubectl apply -f ./service_create.yaml Service的访问 IP: Service 拥有自己的 IP 可以使用该 IP 进行访问，访问进来后会将请求负载到某一个 Pod 上。 DNS: Service 也可以通过域名进行访问。DNS 需要部署 core-dns 或其他 DNS 组件，后面专门研究。 Service负载策略 RoundRobin: 轮询模式，即每一次请求都按次序分发到每一个 Pod 上。 SessionAffinity: 会话亲和模式，即基于客户端 IP 进行会话保持，第一次将请求分发到哪一个 Pod 之后的请求全都分发到该 Pod 上。 Service多端口 同协议：需要指定名称 1234567891011121314apiVersion: v1kind: Servicemetadata: name: webappspec: selector: app: webapp ports: - port: 8081 #第一个端口 targetPort: 8081 name: web - port: 8002 #第二个端口 targetPort: 8002 name: manager 不同协议 1234567891011121314apiVersion: v1kind: Servicemetadata: name: webappspec: selector: app: webapp ports: - name: dns port: 53 portocol: UDP #指定 UDP 协议 - name: dns-tcp port: 53 portocol: TCP #指定 TCP 协议 外部服务Service场景：需要将数据库或其他 namespace 中的服务做为后端服务。可以创建一个没有 label selector 的 Service。然后再手动创建一个和 Service 同名的 Endpoints 。 Service 12345678apiVersion: v1kind: Servicemetadata: name: webappspec: ports: - port: 8081 targetPort: 8081 EndPoint 123456789apiVersion: v1kind: Servicemetadata: name: webappsubsets: - address: - IP: 1.2.3.4 ports: - port: 8081 集群外访问ServicePod 和 Service 都是 k8s 中的概念，对于外部来说都是无法感知的。为了让宿主机能够访问这些服务，可以将Pod 或 Service 的端口号映射到宿主机，使客户端能够通过物理机访问容器内的应用。 将Pod的端口号映射到宿主机端口映射 创建 nginx 的 Pod 12345678910111213apiVersion: v1kind: Podmetadata: name: nginx #指定 Pod名称 labels: name: nginxspec: containers: - name: nginx image: nginx ports: - containerPort: 80 hostPort: 81 1kubectl apply -f ./pod_mapping.yaml 查看 Pod 状态 1234kubectl get pod nginxNAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATESwebapp 1/1 Running 0 61m 172.17.0.7 minikube &lt;none&gt; &lt;none&gt; 如果看 STATUS 状态不是 Running 的话，说明该 Pod 未启动成功 登录 Node 访问该端口 123minikube sshcurl 127.0.0.1:81 #前面指定了映射端口是 81curl 192.168.49.2:81 # Node 的 IP 地址是 192.168.49.2，使用这个 IP 地址与上面效果相同 使用 kubectl get node -o wide 可以查看 Node 的 IP 地址 在查看 Pod 的日志 1234567891011121314151617181920212223242526kubectl logs -f nginx/docker-entrypoint.sh: /docker-entrypoint.d/ is not empty, will attempt to perform configuration/docker-entrypoint.sh: Looking for shell scripts in /docker-entrypoint.d//docker-entrypoint.sh: Launching /docker-entrypoint.d/10-listen-on-ipv6-by-default.sh10-listen-on-ipv6-by-default.sh: info: Getting the checksum of /etc/nginx/conf.d/default.conf10-listen-on-ipv6-by-default.sh: info: Enabled listen on IPv6 in /etc/nginx/conf.d/default.conf/docker-entrypoint.sh: Launching /docker-entrypoint.d/20-envsubst-on-templates.sh/docker-entrypoint.sh: Launching /docker-entrypoint.d/30-tune-worker-processes.sh/docker-entrypoint.sh: Configuration complete; ready for start up2021/09/05 13:40:57 [notice] 1#1: using the &quot;epoll&quot; event method2021/09/05 13:40:57 [notice] 1#1: nginx/1.21.12021/09/05 13:40:57 [notice] 1#1: built by gcc 8.3.0 (Debian 8.3.0-6)2021/09/05 13:40:57 [notice] 1#1: OS: Linux 5.10.47-linuxkit2021/09/05 13:40:57 [notice] 1#1: getrlimit(RLIMIT_NOFILE): 1048576:10485762021/09/05 13:40:57 [notice] 1#1: start worker processes2021/09/05 13:40:57 [notice] 1#1: start worker process 322021/09/05 13:40:57 [notice] 1#1: start worker process 332021/09/05 13:40:57 [notice] 1#1: start worker process 342021/09/05 13:40:57 [notice] 1#1: start worker process 352021/09/05 13:40:57 [notice] 1#1: start worker process 362021/09/05 13:40:57 [notice] 1#1: start worker process 37172.17.0.1 - - [05/Sep/2021:13:41:36 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;curl/7.68.0&quot; &quot;-&quot;192.168.49.2 - - [05/Sep/2021:13:46:06 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;curl/7.68.0&quot; &quot;-&quot; 设置hostNetwork通过设置 hostNetwork=true 将 Pod 中的端口暴露出来，本质上也是暴露端口，只是 hostNetwork 是将所有端口都暴露。 创建 Pod 12345678910111213apiVersion: v1kind: Podmetadata: name: nginx labels: name: nginxspec: hostNetwork: true #设置为 true containers: - name: nginx image: nginx ports: - containerPort: 80 1kubectl apply -f ./pod_mapping.yaml 后面操作与上面一致，登录 node 访问nginx，通过查看日志判断是否有请求到。 将Service的端口号映射到宿主机映射Service端口 创建 Service 123456789101112apiVersion: v1kind: Servicemetadata: name: webappspec: selector: app: webapp type: NodePort ports: - port: 80 targetPort: 80 nodePort: 30000 # 1kubectl apply -f ./service_mapping.yaml 访问 nginx 1curl 127.0.0.1:30000 通过查看 nginx Pod 的日志判断是否请求进来 设置 LoadBalancer例如: 阿里云 SLB DNS服务Kubernetes 1.11 版本开始， DNS 服务由 CoreDNS 提供。 Ingress: HTTP 7层路由在我们部署应用时，我们很多时候的需求是这样的： https://xxx.xx/api 希望将请求打到 api 的 Service 上; https://xxx.xx/web 希望将请求打到 web 的 Service 上； 同时，我们的端口是同一个端口。即是通过 uri 来区分不同的服务。这个功能就需要使用到 Ingress 来进行 HTTP 层的路由转发。","categories":[{"name":"k8s","slug":"k8s","permalink":"https://withoutcause.github.io/categories/k8s/"}],"tags":[{"name":"k8s","slug":"k8s","permalink":"https://withoutcause.github.io/tags/k8s/"}]},{"title":"自学k8s系列~04之Pod","slug":"自学k8s系列-04之Pod","date":"2021-08-27T16:27:54.000Z","updated":"2021-08-27T16:27:54.000Z","comments":true,"path":"2021/08/28/自学k8s系列-04之Pod/","link":"","permalink":"https://withoutcause.github.io/2021/08/28/%E8%87%AA%E5%AD%A6k8s%E7%B3%BB%E5%88%97-04%E4%B9%8BPod/","excerpt":"Pod是什么 Pod 是 K8s 的最小运行单元。 是所有应用的载体，包含一个或多个容器(这里的容器可以不是 Docker)。 Pod 定义","text":"Pod是什么 Pod 是 K8s 的最小运行单元。 是所有应用的载体，包含一个或多个容器(这里的容器可以不是 Docker)。 Pod 定义12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576apiVersion: v1 //需要kind: Pod //需要metadata: //需要 name: string //需要 namaspace: string //需要 labels: - name: string annotations: - name: stringspec: //需要 containers: //需要 - name: string //需要 image: string //需要 imagePullPolice: [Always | Never | IfNotPresent] command: [string] args: [string] workingDir: string volumeMounts: - name: string mountPath: string readOnly: boolean ports: - name: string containerPort: int hostPort: int protocol: string env: - name: string value: stringresources: limits: cpu: string memory: string requests: cpu: string memory: string livenessProbe: exec: command: [string] httpGet: path: string port: int host: string scheme: string httpHeaders: - name: string value: string tcpSocket: port: int initialDelaySeconds: number timeoutSeconds: number periodSeconds: number successThreshold: 0 failureThreshold: 0 securityContext: privileged: falseRestartPolicy: [Always | Never | OnFailure]nodeSelector: objectimagePullSecrets:- name: stringhostNetwork: false volumes: - name: string emptyDir: &#123;&#125; hostPath: path: string secret: secretName: string items: - key: string path: string configMap: name: string items: - key: string path: string Pod 的基本操作Pod 等于 Docker 吗？答案是不等于。Docker 运行在 Pod 中，但是 Pod 可以运行的不仅仅是 Docker, 其他容器也可以。比如: RKT 或者 Podman 都可以在 Pod 中运行。其次，Pod 中的容器也可以有多少。这一点类似于 Docker 中的容器互联。 Pod 创建Pod 的主程序需要一直处于前台运行的状态，否则 Pod 就会将期销毁，这一点跟 Docker 很像。例如: 执行的是 1nohup ./start.sh &amp; Pod 在执行完该命令后，就会将 Pod 销毁。而我们的目的是期望能够后台运行，这就违背了我们的目的。正确做法 1./start.sh 这样该应用就会一直前台运行， Pod 就会一直存在。 命令方式 12# 创建 Pod 指定 namespace 名称为 sjlkubectl create pod podName -n sjl yaml 方式 1234567apiVersion: v1kind: Podmetadata: name: podName namespace: sjlspec: image: nginx:1.19.7 Pod 状态查看12345# 查看所有的 podkubectl get pods# 查看指定 name 的 podkubectl get pod podName Pod 更新1kubectl replace pod Pod 删除1kubectl delete pod podName 查看Pod解析12# 查看指定 name 的 podkubectl get pod podName Pod 显示的内容如下 12NAME READY STATUS RESTARTS AGEnginx-deployment-59f854fb7c-vlkhj 1/1 Running 1 2d23h NAMEPOD 的名称。 READY显示 Pod 的容器信息，以 / 分隔成左右两边，左边是就绪的容器，右边是 Pod 包含的总容器。一般是一个 Pod 一个容器，但是也是例外的情况，一个 Pod 包含多个容器。 STATUS当前 Pod 的状态。 RESTARTSPod 的重启次数。 AGEPod 的运行时间。 Pod与容器 在 k8s 中， Pod 是最小的单元体。 Pod 中可以运行一个或多个容器，这个容器可以是 Docker 也可以是其他容器。当然，我们最常用的还是 Docker 容器。 镜像Pod 被高度到某一台 Node 后，会下载对应的镜像，镜像版本等信息由 image 指定，具体的镜像下载策略 k8s 中的镜像下载策略由 imagePullPolice 指定，下载策略包含以下三种: 1imagePullPolice: [Always | Never | IfNotPresent] Always每次都下载最新镜像。 Never只使用本地镜像，不下载。 IfNotPresent当本地没有时，才下载新镜像。 Pod共享Volume部署 Pod yaml 配置 12345678910111213141516171819202122apiVersion: v1kind: Podmetadata: name: volume-podspec: containers: - name: tomcat image: tomcat:9.0.0 ports: - containerPort: 8080 volumeMounts: - name: app-logs mountPath: /usr/local/tomcat/logs - name: busybox image: busybox command: [&quot;sh&quot;, &quot;-c&quot;, &quot;tail -f /logs/catalina*.log&quot;] volumeMounts: - name: app-logs mountPath: /logs volumes: - name: app-logs emptyDir: &#123;&#125; 1//todo 实验未成功， pod 没有正常启动。 Pod的配置管理ConfigMapkubernetes 提供了一种统一的配置管理方案——ConfigMap 。 ConfigMap 的常用方式: 生成为容器内的环境变量。 设置容器的启动命令启动参数（需要设置为环境变量）。 以 Volume 的形式挂载为容器内的文件或目录。 ConfigMap的保存形式 key: value vlue 可以是一个完整的配置文件 ConfigMap的创建123456apiVersion: v1kind: ConfigMapmetadata: name: pod-configmapdata: key: zhangsan 执行命令 1kubectl apply -f ./pod_configmap.yaml 查看ConfigMap 查看 ConfigMap 1kubectl get configmap 展示内容 123NAME DATA AGEkube-root-ca.crt 1 175dpod-configmap 1 7m54s 查看 ConfigMap 详情信息 1kubectl describe configmap pod-configmap 展示内容 1234567891011Name: pod-configmapNamespace: defaultLabels: &lt;none&gt;Annotations: &lt;none&gt;Data====key:----张三Events: &lt;none&gt; 在Pod中使用ConfigMap ConfigMap 1234567apiVersion: v1kind: ConfigMapmetadata: name: cm-appvarsdata: apploglevel: INFO appdatadir: /var/data Pod 123456789101112131415161718192021apiVersion: v1kind: Podmetadata: name: pod-configmap-applyspec: containers: - name: pod-configmap-apply image: busybox command: [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;env|grep APP&quot;] #启动时执行该命令 env: - name: APPLOGLEVEL #定义环境变量的名称 valueFrom: configMapKeyRef: name: cm-appvars #环境变量的值取自 cm-appvars key: apploglevel #取的 key 为 apploglevel - name: APPDATADIR #定义 APPDATADIR 环境变量 valueFrom: configMapKeyRef: name: cm-appvars #环境变量的值取自 cm-appvars key: appdatadir #取的 key 为 appdatadir restartPolicy: Never 创建 ConfigMap 和 Pod 1234# 创建 ConfigMapkubectl apply -f ./pod_configmap.yaml# 创建 Podkubectl apply -f ./pod_configmap_apply.yaml 查看日志 1234567891011# 查看 Podkubectl get podsNAME READY STATUS RESTARTS AGEpod-configmap-apply 0/1 Completed 0 7m32s# 查看 Pod 名为 pod-configmap-apply 的日志kubectl logs pod-configmap-applyAPPDATADIR=/var/dataAPPLOGLEVEL=INFO 使用 envFrom 创建环境变量 使用 envFrom 创建 Pod 12345678910111213apiVersion: v1kind: Podmetadata: name: pod-configmap-apply-envfromspec: containers: - name: cm-test image: busybox command: [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;env&quot;] envFrom: - configMapRef: name: cm-appvars restartPolicy: Never 启动 Pod 1kubectl apply -f ./pod_configmap_apply_envfrom.yaml 查看 Pod 日志 123456789101112131415161718kubectl logs pod-configmap-apply-envfrom# 在显示的内容中可以看到，我们在 ConfigMap 中设置的两个变量 apploglevel 和 appdatadir 已经加入进来了apploglevel=INFOKUBERNETES_SERVICE_PORT=443KUBERNETES_PORT=tcp://10.96.0.1:443HOSTNAME=pod-configmap-apply-envfromSHLVL=1HOME=/rootKUBERNETES_PORT_443_TCP_ADDR=10.96.0.1PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binKUBERNETES_PORT_443_TCP_PORT=443KUBERNETES_PORT_443_TCP_PROTO=tcpappdatadir=/var/dataKUBERNETES_SERVICE_PORT_HTTPS=443KUBERNETES_PORT_443_TCP=tcp://10.96.0.1:443KUBERNETES_SERVICE_HOST=10.96.0.1PWD=/ 通过Volume使用ConfigMap ConfigMap 配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546apiVersion: v1kind: ConfigMapmetadata: name: pod-configmap-volumedata: # 在 applicationContextXml 放的是整个 xml 文件的配置 applicationContextXml: | &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot; default-autowire=&quot;byName&quot;&gt; &lt;!-- 注意上面的default-autowire=&quot;byName&quot;，如果没有这个声明不会被注入 --&gt; &lt;description&gt;Spring-database配置&lt;/description&gt; &lt;bean id=&quot;aliyunIntranetStorage&quot; class=&quot;com.olymtech.aliyun.client.oss.AliyunStorageImpl&quot;&gt; &lt;property name=&quot;accessID&quot; value=&quot;$&#123;oss.accessID&#125;&quot;/&gt; &lt;property name=&quot;accessKey&quot; value=&quot;$&#123;oss.accessKey&#125;&quot;/&gt; &lt;property name=&quot;ossEndpoint&quot; value=&quot;$&#123;oss.ossIntranetEndpoint&#125;&quot;/&gt; &lt;property name=&quot;bucketName&quot; value=&quot;$&#123;oss.bucketName&#125;&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;aliyunStorage&quot; class=&quot;com.olymtech.aliyun.client.oss.AliyunStorageImpl&quot;&gt; &lt;property name=&quot;accessID&quot; value=&quot;$&#123;oss.accessID&#125;&quot;/&gt; &lt;property name=&quot;accessKey&quot; value=&quot;$&#123;oss.accessKey&#125;&quot;/&gt; &lt;property name=&quot;ossEndpoint&quot; value=&quot;$&#123;oss.ossEndpoint&#125;&quot;/&gt; &lt;property name=&quot;bucketName&quot; value=&quot;$&#123;oss.bucketName&#125;&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;ediAliyunIntranetStorage&quot; class=&quot;com.olymtech.aliyun.client.oss.AliyunStorageImpl&quot;&gt; &lt;property name=&quot;accessID&quot; value=&quot;$&#123;oss-edi.accessID&#125;&quot;/&gt; &lt;property name=&quot;accessKey&quot; value=&quot;$&#123;oss-edi.accessKey&#125;&quot;/&gt; &lt;property name=&quot;ossEndpoint&quot; value=&quot;$&#123;oss-edi.ossIntranetEndpoint&#125;&quot;/&gt; &lt;property name=&quot;bucketName&quot; value=&quot;$&#123;oss-edi.bucketName&#125;&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;ediAliyunStorage&quot; class=&quot;com.olymtech.aliyun.client.oss.AliyunStorageImpl&quot;&gt; &lt;property name=&quot;accessID&quot; value=&quot;$&#123;oss-edi.accessID&#125;&quot;/&gt; &lt;property name=&quot;accessKey&quot; value=&quot;$&#123;oss-edi.accessKey&#125;&quot;/&gt; &lt;property name=&quot;ossEndpoint&quot; value=&quot;$&#123;oss-edi.ossEndpoint&#125;&quot;/&gt; &lt;property name=&quot;bucketName&quot; value=&quot;$&#123;oss-edi.bucketName&#125;&quot;/&gt; &lt;/bean&gt; &lt;/beans&gt; Pod 配置 1234567891011121314151617181920apiVersion: v1kind: Podmetadata: name: pod-configmap-volume-apply # 指定Pod名称spec: containers: - name: pod-configmap-volume-apply # 容器名称 image: tomcat #指定容器镜像 ports: - containerPort: 8080 volumeMounts: #配置挂载 - name: applicationcontextxml #x mountPath: /configfiles volumes: - name: applicationcontextxml configMap: name: pod-configmap-volume items: - key: applicationContextXml path: applicationContext.xml 验证结果 1234567891011121314151617181920212223242526272829# 部署 ConfigMapkubectl apply -f ./pod_configmap_volume.yaml# 部署 Podkubectl apply -f ./pod_configmap_volume_apply.yaml# 查看日志kubectl get podsNAME READY STATUS RESTARTS AGEpod-configmap-volume-apply 1/1 Running 0 4m49s# 如果 READY 是 0/1 多执行几次 kubectl get pos, pod 还没启动成功# 进入 pod 查看目录kubectl exec -it pod-configmap-volume-apply -- bash# 前面是进入 pod 的默认目录，而配置挂载在 / 目录下root@pod-configmap-volume-apply:/usr/local/tomcat# ls /bin boot configfiles dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var#可以看到，有一个 configfiles 目录#进入 configfiles 查看是否存在 applicationContext.xmlroot@pod-configmap-volume-apply:/usr/local/tomcat# cd /configfiles/root@pod-configmap-volume-apply:/configfiles# lsapplicationContext.xml# 可以看到，出现了 applicationContext.xmlroot@pod-configmap-volume-apply:/configfiles# cat applicationContext.xml# 查看 applicationContext.xml 的内容 Pod的生命周期和重启策略Pod的生命周期Pod 的生命周期被定义为各种状态， Pod 的状态有五种分别是：Pending 、Running 、Successed 、Failed 、Unknown 。 状态 描述 Pending 等待，Pod 已经创建，但是Pod内的容器或者镜像还没创建。 Running 运行中,Pod 内所有容器均已创建，正在运行中。 Successed 执行成功，该状态表示 Pod 已经执行成功并退出，且不会重启容器。 Failed 执行失败，该状态表示 Pod 已经退出，但是至少有一个容器为失败状态。 Unknown 未知，无法获取到 Pod 的正确状态，这种情况一般是网络故障。 Pod的重启策略Pod 的重启策略应用于 Pod 内的所有容器，并且仅在 Pod 所处的 Node 上由 kubelet 进行判断和重启操作。当某个容器异常退出或者健康检查失败时，kubelet 将根据 RestartPolicy 配置的重启策略进行相应的处理。 Pod 的重启策略主要有三种，分别是: Always 、OnFailure 、Never 。 配置值 描述 Always 当容器失效时，由 kubelet 自动重启该容器。默认值。 OnFailure 当容器终止运行，且退出状态码不为 0 时， kubelet 自动重启该容器。 Never 无论处于何种状态，kubelet 都不会重启该容器。 12345678910111213apiVersion: v1kind: Podmetadata: name: pod-configmap-apply-envfromspec: containers: - name: cm-test image: busybox command: [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;env&quot;] envFrom: - configMapRef: name: cm-appvars restartPolicy: Never #手动配置该 Pod 的重启策略为 Never Pod 的健康检查，扩缩容，滚动更新以及回滚后面再专门的记录。","categories":[{"name":"k8s","slug":"k8s","permalink":"https://withoutcause.github.io/categories/k8s/"}],"tags":[{"name":"k8s","slug":"k8s","permalink":"https://withoutcause.github.io/tags/k8s/"}]},{"title":"自学k8s系列~03之YAML","slug":"自学k8s系列-03之YAML","date":"2021-08-26T11:01:40.000Z","updated":"2021-08-26T11:01:40.000Z","comments":true,"path":"2021/08/26/自学k8s系列-03之YAML/","link":"","permalink":"https://withoutcause.github.io/2021/08/26/%E8%87%AA%E5%AD%A6k8s%E7%B3%BB%E5%88%97-03%E4%B9%8BYAML/","excerpt":"YAML是什么基本语法 大小写敏感。 使用缩进来表示层级关系。 使用空格而不是 tab。 缩进的空格数要对齐，相同层级要对齐。 # 表示注释。对比 JSON 无法写注释这一点，强太多。","text":"YAML是什么基本语法 大小写敏感。 使用缩进来表示层级关系。 使用空格而不是 tab。 缩进的空格数要对齐，相同层级要对齐。 # 表示注释。对比 JSON 无法写注释这一点，强太多。 数据类型 对象 数组 纯量 对象 键值对的集合，即 Map 对象的一组键值对表示。 1key: value 数组1234key:- value1- value2- value3 每个 value 和横杠(-) 之间有一个空格。 纯量 单个，不可以再分的值 纯量包含以下值: 字符串 布尔值 数值 Null 时间 日期 字符串表示 简单字符串示例 1name: sjl #最简单的字符串示例 特殊符号字符串 1name: &#x27;sjl sjl&#x27; #包含空格等特殊字符，需要放在引号中 单引号和双引号 12name: &#x27;sjl \\n sjl&#x27;name: &quot;sjl \\n sjl&quot; 单引号会对特殊字符 进行转义。上面示例中的 \\n 会转义为 \\\\n 在展示的时候，还是字符串。双引号不会对特殊字符转义，上面示例中的 \\n 不会转义，字符串的表示还是为 \\n ，这样在某些编程语言中会视作换行符。 单引号转义 1name: &#x27;sjl&#x27;&#x27;s&#x27; 上面示例中的 &#39; 单引号是字符串的一部分，需要再添加一个单引号将其转义。与 Java 中的 \\ 转义符含义类似。 布尔值布尔值用 true 和 false 来表示 12enable: trueenable: false 数值1number: 111 nullnull 使用 ~ 来表示。 1person: ~ 日期日期采用 ISO 8601 表示法，一般为 yyyy-MM-dd 的格式 1date: 2021-08-26 时间日期和时间之间，使用 T 进行分隔 1datetime: 2021-08-26T22:03:44 完整示例123456789101112131415161718192021apiVersion: apps/v1kind: Deploymentmetadata: name: nginx-deployment labels: app: nginxspec: replicas: 1 selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: containers: - name: nginx image: nginx:1.17.9 ports: - containerPort: 8088 k8s配置内容k8s 配置 yaml 文件主要包含以下五块内容: apiVersion: 当前配置格式的版本 kind: 要创建资源的类型， Deployment 、Pod 、Service 、Namespace 、ReplicaSet 、DeanmonSet、 Job 、CronJob 等 metadata: 元数据, name 是必选项。 spec: 是对应 kind 类型的说明。 status: 是资源当前的状态，kubernetes 会尽最大努力使 spec 和 status 相匹配。 YAML 如何加载1kubectl apply -f yaml_file_path 部署 nginx 的 YAML 123456789101112131415161718192021apiVersion: apps/v1kind: Deploymentmetadata: name: nginx labels: app: nginxspec: replicas: 1 selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: containers: - name: nginx image: nginx:1.19.7 ports: - containerPort: 8088 执行 kubectl apply -f deployment.yaml 创建 Deployment 。 部署 YAML 准备 YAML 文件 1234567891011121314151617181920apiVersion: apps/v1kind: Deploymentmetadata: name: nginx-deployment namespace: sjlspec: replicas: 1 selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: containers: - name: nginx image: nginx:1.19.7 ports: - containerPort: 80 部署到 k8s 中 1kubectl apply -f ./deployment.yaml 用 curl 发起 http 请求 主要步骤：1. 查看部署的 pod 的 IP 地址 12345# 查看部署的 pod 的 IP 地址kubectl get pods -n sjl -o wide# 下面是输出结果NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATESnginx-deployment-59f854fb7c-vlkhj 1/1 Running 0 12m 172.17.0.5 minikube &lt;none&gt; &lt;none&gt; 可以看到 IP 是 172.17.0.5，进入 minikube 的 ssh 中，然后使用 curl 发起 http 请求 12345# 进行 minikube 的 ssh 中minikube ssh# 使用 curl 发起请求curl 172.17.0.5 在查看 pod 的 log 是否有记录 1234567891011kubectl logs nginx-deployment-59f854fb7c-vlkhj -n sjl# 下面是打印的日志/docker-entrypoint.sh: /docker-entrypoint.d/ is not empty, will attempt to perform configuration/docker-entrypoint.sh: Looking for shell scripts in /docker-entrypoint.d//docker-entrypoint.sh: Launching /docker-entrypoint.d/10-listen-on-ipv6-by-default.sh10-listen-on-ipv6-by-default.sh: info: Getting the checksum of /etc/nginx/conf.d/default.conf10-listen-on-ipv6-by-default.sh: info: Enabled listen on IPv6 in /etc/nginx/conf.d/default.conf/docker-entrypoint.sh: Launching /docker-entrypoint.d/20-envsubst-on-templates.sh/docker-entrypoint.sh: Launching /docker-entrypoint.d/30-tune-worker-processes.sh/docker-entrypoint.sh: Configuration complete; ready for start up172.17.0.1 - - [27/Aug/2021:16:16:39 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;curl/7.68.0&quot; &quot;-&quot; 可以在最后一行看到，发起了 http 请求。","categories":[{"name":"k8s","slug":"k8s","permalink":"https://withoutcause.github.io/categories/k8s/"},{"name":"yaml","slug":"yaml","permalink":"https://withoutcause.github.io/categories/yaml/"}],"tags":[{"name":"yaml","slug":"yaml","permalink":"https://withoutcause.github.io/tags/yaml/"},{"name":"yml","slug":"yml","permalink":"https://withoutcause.github.io/tags/yml/"},{"name":"k8s配置","slug":"k8s配置","permalink":"https://withoutcause.github.io/tags/k8s%E9%85%8D%E7%BD%AE/"}]},{"title":"Docker问题记录","slug":"Docker问题记录","date":"2021-08-25T09:13:01.000Z","updated":"2021-08-25T09:13:01.000Z","comments":true,"path":"2021/08/25/Docker问题记录/","link":"","permalink":"https://withoutcause.github.io/2021/08/25/Docker%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/","excerpt":"Docker 客户端无法 push 到远程仓库 问题 在使用 Docker 本地仓库时，push 镜像到仓库报错","text":"Docker 客户端无法 push 到远程仓库 问题 在使用 Docker 本地仓库时，push 镜像到仓库报错 1http: server gave HTTP response to HTTPS 原因 docker 客户端使用的是 https 协议发起请求，而仓库使用的是 http 协议给出的响应 解决方式 在 /etc/docker/deamon.json 文件中添加如下配置： 1&quot;insecure-registries&quot; : &quot;192.168.3.202:8080&quot; 如果是 mac 系统，在 docker ,操作方式如下：右键点击桌面顶栏的 docker 图标，选择 Preferences ，在 Daemon 标签下的 Insecure registries 列表中将地址添加到数组里。 个人猜测， http 是不安全的请求，默认是发起 https 请求，所以需要将该列表添加进不安全列表中。","categories":[{"name":"Docker","slug":"Docker","permalink":"https://withoutcause.github.io/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://withoutcause.github.io/tags/Docker/"}]},{"title":"Docker——操作篇","slug":"Docker——操作篇","date":"2021-08-25T09:05:22.000Z","updated":"2021-08-25T09:05:22.000Z","comments":true,"path":"2021/08/25/Docker——操作篇/","link":"","permalink":"https://withoutcause.github.io/2021/08/25/Docker%E2%80%94%E2%80%94%E6%93%8D%E4%BD%9C%E7%AF%87/","excerpt":"以前学习 Docker 的笔记，主要是一些 Docker 的操作。 使用 Docker 镜像Docker 运行容器前需要本地存在对应的镜像，如果镜像没保存在本地， Docker 会尝试先从默认镜像仓库下载(默认使用 Docker Hub 公共注册服务器中的仓库)，也可以通过配置，使用自定义的镜像仓库。","text":"以前学习 Docker 的笔记，主要是一些 Docker 的操作。 使用 Docker 镜像Docker 运行容器前需要本地存在对应的镜像，如果镜像没保存在本地， Docker 会尝试先从默认镜像仓库下载(默认使用 Docker Hub 公共注册服务器中的仓库)，也可以通过配置，使用自定义的镜像仓库。 获取镜像使用 docker pull命令直接从 Docker Hub 镜像源来下载镜像。命令格式 1234docker pull NAME[: TAG]# NAME 是镜像的仓库名称# TAG 是镜像的标签# 对于 Docker 镜像来说，如果不显式指定 TAG 则默认会选择 latest 标签，这会下载仓库中最新版本的镜像。 docker pull 命令 NAME 中还应包含 registry 默认为 docker hub，即 registry.hub.docker.com ，如果从其他 registry 中下载镜像 1docker pull hub.c.163.com/public/ubuntu:14.04 pull 命令支持的选项 a, –all-tags=true|false: 是否获取仓库中所有镜像，默认为否 查看镜像信息使用 images 命令列出镜像1docker images 上面命令可以列出本地主机上已有镜像的基本信息 12REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZEhub.c.163.com/public/ubuntu 14.04 f6a575b7c805 2 years ago 237.1 MB REPOSITORY 来自于哪个仓库 TAG 镜像的标签信息 IMAGE ID 镜像的 ID CREATED 创建时间，说明镜像的最后更新时间 VIRTUAL SIZE 镜像大小 images 子命令主要支持的选项 -a, –all=true|false : 列出所有的镜像文件（包括临时文件），默认为false –digests=true|false : 列出镜像的数字摘要值，默认为false -f, –filter=[] : 过滤列出的镜像， –format=”TEMPLATE” : 控制输出格式，如 ID 代表 ID 信息， Repository 代表仓库信息等 –no-trunc=true|false : 对输出结果中太长的部分是否进行截断，如镜像的 ID 信息，默认为 true -q, –quiet=true|false : 仅输出 ID 信息，默认为 false 使用 tag 命令添加镜像标签1docker tag ubuntu:latest mybuntu:latest 添加一个新的 myubuntu:latest 镜像标签 使用 inspect 命令查看详细信息1docker inspect mybuntu:14.04 返回的是 JSON 格式的长信息，如果只需要其中一项内容时，可以使用参数 -f 来指定。 1docker inspect -f &#123;&#123;&quot;.Architecture&quot;&#125;&#125; 使用 history 命令查看镜像历史1docker history centos:7.0 过长的命令会被自动截断，可以使用 --no-trunc 选项输出完整命令 1docker history --no-trunc centos:7.0 搜寻镜像使用 docker search 命令可以搜索远端仓库中共享的镜像，默认搜索官方仓库中的镜像。用法为 docker search TERM ，支持的参数主要包括 –automated=true|false : 仅显示自动创建的镜像，默认为 false –no-trunc=true|false : 输出信息不截断显示，默认为 false -s, –stars=X : 指定仅显示评价为指定星级以上的镜像，默认为 0，输出所有镜像 删除镜像使用标签删除镜像1docker rmi myubuntu:latest 当某个镜像有多个标签时，删除指定的标签，而不会删除标签所指向的镜像。但当镜像只有一个标签时，会将镜像彻底删除 使用镜像 ID 删除镜像1docker rmi IMAGEID 当有容器在运行时，无法删除，可以使用 -f 选项进行强制删除 创建镜像创建镜像的方式有三种： 基于已有镜像的容器创建 基于本地模板导入 基于 Dockerfile 创建 基于已有镜像的容器创建命令格式： 1docker commit[OPTIONS]CONTAINER[REPOSITORY[: TAG]] 主要选项包括： -a, –author=””: 作者信息 -c, –change=[]: 提交的时候执行 Dockerfile 指令 -m, –message=”” : 提交消息 -p, –pause=true : 提交时暂停容器运行 1docker commit -m &quot;new file&quot; -a &quot;sjl&quot; c8ac5a420141 test:1.0 基于本地模板导入用户可以直接从一个操作系统模板文件中导入一个镜像，主要使用 docker import 命令，其命令格式为 1docker import[OPTIONS] file|URL|-[REPOSITORY[:TAG]] 未测试 存出和载入镜像存出镜像如果要导出镜像到本地文件，可以使用 docker save 命令。 1docker save -o outputpath image 演示命令 1docker save -0 centos_7.0.tar centos:7.0 载入镜像可以使用 docker load 命令将导出/存出的镜像导入到本地镜像库 1docker load centos_7.0.tar 上传镜像使用 docker push 命令上传镜像到仓库，默认上传到 Docker Hub 官方仓库，其命令格式为： 1docker push NAME[:TAG]|[REGISTRY_HOST [:REGISTRY_PORT]/]NAME[:TAG] 未测试，注册 docker hub 或阿里云 docker 账号后进行测试 操作 Docker 容器容器是 docker 另一个核心概念，容器是镜像的运行实时。镜像是静态只读文件，而容器带有运行时需要的可写文件层。 创建容器新建容器新建容器使用 docker create 命令 1docker create -it centos:7.0 使用 docker crate 命令新建的容器处于停止状态，可以使用 docker start 命令来启动它。 启动容器使用 docker start 命令来启动一个已经创建的容器 1docker start ID 使用 docker ps -a 查看所有镜像 docker ps 查看一个运行中的容器 新建并启动容器容器启动步骤 docker create 创建容器 docker start 启动容器使用 docker run 命令将创建容器和启动容器合并成一个步骤1docker run centos:7.0 /bin/echo &#x27;hello world!&#x27; 当利用 docker run 来创建并启动容器时，Docker 在后台运行操作： 检查本地是否存在指定的镜像，不存在就从公有仓库下载 利用镜像创建一个容器，并启动该容器 分配一个文件系统给容器，并在只读的镜像外面挂载一层可读写层 从宿主机配置的网桥接口中桥接一个虚拟接口到容器中 从网桥的地址池配置一个 IP 地址给容器 执行用户指定的应用程序 执行完毕后容器被自动终止 使用 Ctrl + d 或输入 exit 命令来退出容器 常见的错误代码 125 : Docker daemon 执行出错，例职指定了不支持的 Docker 命令参数 126 : 所指定命令无法执行，例如权限出错 127 : 容器内命令无法找到 守护态运行正常的生产环境下，我们需要让 Docker 容器在后台以守护态(Daemonized)形式运行，此时可以通过添加 -d 参数来实现 1docker run -d centos:7.0 获取容器的输出信息1docker logs id 终止容器使用 docker stop 来终止一个运行中的容器。该命令格式为 docker stop[-t|--time[=10]][CONTAINER...]首先向容器发送 SIGTERM 信号，等待一段超时时间(默认为 10 秒)后，再发送 SIGKILL 信号来终止 容器 1docker stop id docker killdocker kill 命令会直接发送 SIGKILL 信号来强行终止容器。 当 Docker 容器中指定的应用终结时，容器也会自动终止处于终止状态的容器，可以通过 docker start 命令来重新启动 重启容器1docker restart id 会将一个运行状态的容器先终止，然后再重启 进入容器使用 -d 参数启动的 docker 容器，无法看到容器的信息，也无法进行操作，此时如果需要进入容器进行操作，有多种方法： attach 命令1docker attach [--detach-keys[=[]]] [--no-stdin] [--sig-proxy[[=true]]CONTAINER 支持三个主要选项 –detach-keys[=[]] : 指定退出 attach 模式的快捷键序列，默认是 CTRL -P CTRL -Q –no-stdin=true|false : 是否关闭标准输入，默认是保持打开 -sig-proxy=true|false : 是否代理收到的系统信号给应用进程，默认为 true exec 命令(推荐)docker 从 1.3.0 提供了一个更加方便的 exec 命令，可以在容器内直接执行任意命令 1docker exec [-d|--detach][--detach-keys[=[]]][-i|--interactive][--privileged][-t|--tty][-u|--user[=USER]]CONTAINER COMMAND [ARG...] 参数： -i, –interactive=true|false : 打开标准输入接受用户输入命令，默认为 false –privileged=true|false : 是否给执行命令以最高权限，默认为 false -t, –tty=true|false : 分配伪终端，默认为 false u, –user=”” : 执行命令的用户名或 ID1docker exec -it id /bin/bash nsenter 工具额外安装工具包 删除容器使用 docker rm 命令来删除处于终止或退出状态的容器，其命令格式为 `docker rm[-f|–force][-l|–link][-v|–volumes]CONTAINER[CONTAINER…]主要支持的选项 -f, –force=false : 是否强行终止并删除一个运行中的容器 -l, –link=false : 删除容器的连接，但保留容器 -v, –volumes=false : 删除容器挂载的数据卷 导出和导入容器导出容器导出容器是指导出一个已经创建的容器到一个文件，不管此时这个容器是否牌运行状态，可以使用 docker export 命令，该命令的格式为 1docker[-o|--output[=&quot;&quot;]]CONTAINER 通过 -o 选项来指定导出的 tar 文件名，也可以直接通过重定向来实现 导入容器导出的文件可以使用 docker import 命令变成镜像，该文件格式为： 1docker import [-c|--change[=[]]][-m|--message[=MESSAGE]]file|URL|-[REPOSITORY[:TAG]] 用户可以通过 -c, --change=[] 选项在导入的同时执行容器进行修改的 Dockerfile 指令 docker load 和 docker import 的区别两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息，而镜像存储文件将保存完整记录，体积也更大。容器快照文件导入时可以重新指定标签等元数据信息 访问 Docker 仓库仓库(Repository)是集中存放镜像的地方，分公有仓库和私有仓库。仓库存放在注册服务器上，一个注册服务器可以有多个仓库，一个仓库下可以有多个镜像 Docker Hub 公有镜像市场登录通过命令行执行 docker login 命令来输入用户名、密码和邮箱来完成注册和登录。注册成功后，本地用户目录的 .dockercfg 中将保存用户的认证信息 基本操作用户无需登录即可通过 docker search 命令来查找官方仓库中的镜像，并利用 docker pull 命令来将它下载到本地 自动创建 待测试 时速云镜像市场查看镜像访问 https://hub.tenxcloud.com , 即可看到已存在的仓库和存储的镜像 下载镜像下载镜像使用 docker pull 命令，需要在镜像名称前添加注册服务器的具体地址。格式为：index.tenxcloud.com/&lt;namespace&gt;/&lt;repository&gt;:&lt;tag&gt; 搭建本地私有仓库使用 registry 镜像创建私有仓库安装 Docker 后，可以通过官方提供的 registry 镜像来简单搭建一套本地私有仓库环境 1docker run -d -p 50000:50000 registry 管理私有仓库查看系统已经有镜像使用 docker push 上传标记的镜像Docker 数据管理数据卷数据卷本质上是将一个 Linux 中的目录映射到容器中，数据卷存在在物理机(宿主机)之上，不会因为删除容器而丢失数据。 挂载目录作为数据卷 -v123456# 在 /home/sjl/ 下创建 dataVolume 目录 [root@localhost ~]# mkdir /home/sjl/dataVolume# 映射 dataVolume 为容器中的 home 目录[root@localhost ~]# docker run -it --name centos -v /home/sjl/dataVolume:/home centos /bin/bash# 在容器中的 /home 目录下创建一个文件，在宿主机中即可查看到 映射的目录必须是绝对路径，不允许是相对路径，如果目录不存在， Docker 会自动创建 数据卷权限在启动容器时，默认的用户权限是 rw，即可读写。如果仅仅只是为了可读，需要指定为 ro 12[root@localhost ~]# docker run -it --name centos -v /home/sjl/dataVolume:/home:ro centos /bin/bash 在数据卷中增加错误提示： touch: cannot touch ‘b.md’: Read-only file system -v 参数也支持挂载一个文件到 docker 中，但是不推荐这样做 数据卷容器数据卷容器，就是将一个容器做为数据卷，提供其他容器挂载。其方式类似于数据卷的做法，区别在于使用的是一个容器。 命令 –volumes-from创建数据卷容器12345[root@localhost ~]# docker -it -v /dataVolumes --name data centos# 此时会在容器中的根目录创建一个 dataVolumes 目录[root@localhost ~]# docker -it --volumes-from data --name c1# 此时创建一个容器，使用数据卷容器 data 的 dataVolume 映射为本地的目录 在容器中操作的所有目录都将会在容器卷 data 中产生，即创建文件，删除文件等都在对应的容器卷中产生。 端口映射与容器互联端口映射从外部访问到 Docker 容器中的应用时，我们如果不将容器中的端口开放出来，就不能访问到内部应用，想要实现访问内部应用的功能就必须要将端口开放。端口开放的方法就是将容器中的端口映射为宿主机的端口，通过访问宿主机的端口从而访问容器的端口。 端口映射命令-p(小写) -P(大写)，两个参数的区别在于 -p(小写)需要手动指定端口 -P(大写)不需要手动指定端口，自动随机映射宿主机端口 -p(小写)支持的格式有： IP:HostPort:ContainerPort : 指定 IP 的指定端口映射 IP::ContainerPort : 指定 IP 的随机端口 HostPort:ContainerPort(常用) : 所有 IP 的随机端口 使用 -P(大写) 随机映射 redis 的端口 1[root@localhost ~]# docker run -it -P --name redis redis 使用 -p(小写) 映射所有宿主机的 IP 的指定端口 1[root@localhost ~]# docker run -it -p 16379:6379 --name redis redis –name 为容器指定名称，容器名称不能相同，否则不能创建容器。如果容器名称已经存在，要删除之前的容器才能创建。 容器互联容器互联命令 –link 参数，可以让容器之间进行互联容器互联的意义在于，可以直接将容器进行连接，而不通过宿主机，这样就避免了端口暴露在外。常用的就是，在部署应用的容器中，连接数据库的容器，这样就可以直接连接到数据库。12[root@localhost ~]# docker run -d --name db mysql:5.7[root@localhost ~]# docker run -d -P --name web --link db:mysql java 使用 Dockerfile 创建镜像Dockerfile 是一个文本格式的配置文件，用户可以使用 Dockerfile 来快速创建自定义的镜像。 基本结构Dockerfile 分为四部分： 基础镜像信息 维护者信息 镜像操作指令 容器启动时执行指令 指令说明FROM指定所创建镜像的基础镜像，如果本地不存在，则默认会去 Docker Hub 下载指定镜像。格式为 FROM &lt;image&gt; 或 FROM&lt;image&gt;:&lt;tag&gt;，或 FROM &lt;image&gt;@&lt;digest&gt;任何 Dockerfile 中的第一条指令必须为 FROM 指令，如果同一个 Dockerfile 中创建多个镜像，可以使用多个 FROM 指令。 MAINTAINER指定维护者信息，格式为 MAINTAINER&lt;name&gt;，该信息会写入生成镜像的 Author 属性域中。 RUN运行指令命令。格式为 RUN&lt;command&gt; 或 RUN[“executable”, “param1”, “param2”]。每条 RUN 指令在当前镜像的基础上执行指定命令，并提交为新的镜像。当命令较长时可以使用 \\ 来换行。 CMDCMD 指令用来指定启动容器时默认执行的命令。它支持三种格式： CMD[“executable”, “param1”, “param2”] 使用 exec 执行，是推荐的方式 CMD command param1 param2 在 /bin/bash 中执行，提供给需要交互的应用 CMD[“param1”, “param2”] 提供给 ENTRYPOINT 的默认参数如果用户启动容器时手动指定了运行的命令(作为run的参数)，则会覆盖掉CMD指定的命令。 LABELLABEL 指令用来指定生成镜像的元数据标签信息。格式为 LABEL&lt;key&gt;=&lt;value&gt;… EXPOSE声明镜像内服务所监听的端口。格式为 EXPOSE&lt;port&gt;[&lt;port&gt;…]该指令只是起到声明作用，并不会自动完成端口映射。 ENV指定环境变量，在镜像生成过程中会被后续RUN指令使用，在镜像启动的容器中也会存在。格式为 ENV&lt;key&gt;&lt;value&gt; 或 ENV&lt;key&gt;=&lt;value&gt;…指令指定的环境变量在运行时可以被覆盖的。 docker run –env&lt;key&gt;=&lt;value&gt; built_image ADD该命令将复制指定的&lt;src&gt;路径下的内容到容器中的&lt;dest&gt;路径下。格式为：ADD&lt;src&gt;&lt;dest&gt;，其中&lt;src&gt;可以是 Dockerfile 所在目录的一个相对路径(文件或目录)，也可以是一个 URL，还可以是一个 tar 文件。&lt;dest&gt;可以是镜像内的绝对路径，或者相对于工作目录(WORKDIR)的相对路径。路径支持正则表达式 COPY复制本地主机的&lt;src&gt;(为 Dockerfile 所在目录的相对路径、文件或目录)下的内容到镜像中的&lt;dest&gt;下。目标路径不存在时，会自动创建。路径同样支持正则表达式。当使用本地目录为源目录时，推荐使用 COPY ENTRYPOINT指定镜像的默认入命令，该入口命令会在启动容器时作为根命令执行，所有传入值作为该命令的参数。支持两种格式： ENTRYPOINT [“executable”, “param1”, “param2”](exec 中执行) ENTRYPOINT command param1 param2 (shell 中执行)每个 Dockerfile 中只能有一个 ENTRYPOINT ， 当指定多个时，只有最后一个有效。在运行时，可以被 –entrypoint 参数覆盖掉，如 docker run –entrypoint VOLUME创建一个数据卷挂载点。格式为 VOLUME[“/data”] 可以从本地主机或其他宫挂载数据卷，一般用来存放数据库和需要保存的数据等。 USER指定运行容器时的用户名或UID，后续的 RUN 等指令也会使用指定的用户身份。格式为 USER daemon WORKDIR为后续的 RUN、CMD 和 ENTRYPOINT 指令配置工作目录。格式为 WORKDIR/path/to/workdir可以使用多个 WORKDIR 指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。例如： 12345WORKDIR /aWORKDIR bWORKDIR cRUN pwd# 最终路径为 /a/b/c ARG指定一些镜像内使用的参数 (例如版本号信息等)，这些参数在执行 docker build 命令时才以 –build-arg&lt;varname&gt;=&lt;value&gt; 格式传入。格式为：ARG&lt;name&gt;[=&lt;default value&gt;] ONBUILD配置当所创建的镜像作为其他镜像的基础镜像时，所执行的创建操作指令。格式为 ONBUILD[INSTRUCTION] STOPSIGNAL指令所创建镜像启动的容器接收退出的信号值。例如： 1STOPSIGNAL signal HEALTHCHECK配置扎启动容器如何进行健康检查(如何判断健康与否)，自 Docker 1.12 开始支持。格式有两种： HEALTHCHECK [OPTIONS] CMD command #根据所执行命令返回值是否为 0 来判断 HEALTHCHECK[OPTIONS] CMD command #根据所执行命令返回值是否为 0 来判断 SHELL指定其他命令使用 shell 时默认 shell 类型。默认值为 [“/bin/sh”, “-c”] 创建镜像编写完成 Dockerfile 之后，可以通过 docker build 命令来创建镜像。基本格式为 docker build [选项]内容路径，该命令将读取指定路径下(包括子目录)的 Dockerfile，并将该路径下的所有内容发送给 Docker 服务端，由服务端来创建镜像。 如果使用非内容路径下的 Dockerfile，可以通过 -f 选项来指定其路径 要指定生成镜像的标签信息，可以使用 -t 选项 使用 .dockerignore 文件可以通过 .dockerignore 文件(每一行添加一条匹配模式)来让 Docker 忽略匹配模式路径下的目录和文件。例如： 12345# comment */temp* */*/temp* tmp? -* 使用 Dockerfile 构建 Docker 镜像 明日任务,未完成在周末使用 Dockerfile 构建一次镜像 最佳实践 精简镜像用途 : 尽量让每个镜像的用途都比较集中、单一，避免构造大而复杂、多功能的镜像； 选用合适的基础镜像 : 过大的基础镜像会造成生成臃肿的镜像 提供足够清晰的命令注释和维护者个 正确使用版本号 减少镜像层数 及时删除临时文件和缓存文件 提高生成速度 调整合理的指令顺序 减少外部源的干扰 实战案例使用官方镜像创建容器busybox 的安装12[root@localhost ~]# docker pull busybox[root@localhost ~]# docker run -it --name busybox busybox:latest Ubuntu 的安装1[root@localhost ~]# docker run -it ubuntu /bin/bash CentOS 的安装1[root@localhost ~]# docker run -it centos /bin/bash Nginx 的安装1[root@localhost ~]# docker run -d --name nginx -p 80:80 -p 443:443 nginx 在启动 nginx 的时候，可以添加 -v 选项指定目录 Jenkins 的安1[root@localhost ~]# docker run -p 8080:8080 -p 50000:50000 --name myjenkins jenkins 使用断卷容器映射出 Jenkins 的操作目录 数据库相关容器的创建 MySQL1[root@localhost ~]# docker run -d --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123 mysql docker 容器互联，应用容器连接至数据库容器 日志 配置文件 自定义配置文件 使用命令传入 MongoDB1[root@localhost ~]# docker run -d --name mongodb -p 27017：2 mongo","categories":[{"name":"Docker","slug":"Docker","permalink":"https://withoutcause.github.io/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://withoutcause.github.io/tags/Docker/"}]},{"title":"自学k8s系列~02之k8s主要概念","slug":"自学k8s系列-02之k8s主要概念","date":"2021-08-24T14:31:40.000Z","updated":"2021-08-24T14:31:40.000Z","comments":true,"path":"2021/08/24/自学k8s系列-02之k8s主要概念/","link":"","permalink":"https://withoutcause.github.io/2021/08/24/%E8%87%AA%E5%AD%A6k8s%E7%B3%BB%E5%88%97-02%E4%B9%8Bk8s%E4%B8%BB%E8%A6%81%E6%A6%82%E5%BF%B5/","excerpt":"k8s主要概念Cluster","text":"k8s主要概念Cluster 集群。各种资源的集合。 Master Master 是 Cluster 的大脑，主要负责调度，决定应用在哪里运行。 Node 运行容器的载体，由 Master 管理。Node 管理容器的生命周期。 Pod 是 k8s 的最小单元，pod 可以包含一个或者多个容器。 pod 会被 Master 调度到某一个 node 上运行。 Controller k8s 通过 Controller 来管理 pod。Controller 有以下分类： Deployment 最常用的 Controller 用于部署。 ReplicaSet 使用 Deloyment 时会自动创建 ReplicaSet ，创建多个 Pod 副 本，实际上是通过 ReplicaSet 来实现的。通常情况下，我们不需要直接使用 ReplicaSet 。 DeamonSet 用于每个 Node 最多只运行一个 Pod 的场景。通常用于运行 Demon 。 StatefuleSet 能够保证每个 Pod 在生命周期内名称是不变的，其他 Controller 不能提供该功能。 当发生故障需要删除 Pod 并重启时，Pod 的名称会发生变化，同时 SttatefuleSet 能保证副本按照固定的顺序启动、更新或者删除。 Job 用于运行结束就删除的 Pod ，而其他 Controller 创建的 Pod 会一直运行。 Service 访问容器的入口，对外提供自己的 ip 和 端口。 为 Pod 提供了负载均衡。 服务发现。集群中其他服务可以通过 Service 名字访问后端服务（DNS），也可以通过环境变量访问。 Namespace 将一个 Cluster 进行逻辑上的划分。 不同的 Namespace 资源是完全隔离的。 系统默认会创建两个 Namespace :default 和 kube-system 。 操作k8s资源安装 k8sminikube 安装教程 k8s官方安装教程 启动 k8s1sjl@sjldeMacBook-Pro  ~  minikube start 启动之前必须先安装 Docker 并启动，否则无法成功启动。 命令行操作1kubectl [flags] [options] flags 主要包含以下操作: create get edit delete run describe exec apply Namespace创建 Namespace 命令方式 1kubectl create namespace sjl yaml 方式 1234apiVersion: v1kind: Namespacemetadata: name: sjl-yaml 将上面的这一段脚本保存为 ns_create.yaml ，执行以下命令： 1kubectl apply -f ./ns_create.yaml namespace 可以简写为 ns。namespace 名称校验规则: [a-z0-9]([-a-z0-9]*[a-z0-9])? ，只能使用小写字母中横线和数字，且只能以小写字母开头。 删除 Namespace 命令方式 1kubectl delete namespace sjl yaml 方式 1kubectl delete -f ./ns_create.yaml 查看所有 Namespace1kubectl get namespace Pod&amp;Deployment创建 Deployment 命令方式 1kubectl create deployment nginx-deployment --image=nginx:1.7.9 --replicas=2 -n sjl 创建 deployment ，指定名称为 nginx-deployment 镜像为: nginx:1.7.9 副本为 2 个， namespace 为 sjl yaml 12345678910111213141516171819202122apiVersion: apps/v1kind: Deploymentmetadata: name: nginx-deployment namespace: sjl labels: app: nginxspec: replicas: 1 selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: containers: - name: nginx image: nginx:1.17.9 ports: - containerPort: 8088 1kubectl apply -f ./deployment_crate.yaml 创建了 Deployment 就会创建对应的 Pod 。查看 Pod 1kubectl get pods -n sjl","categories":[{"name":"k8s","slug":"k8s","permalink":"https://withoutcause.github.io/categories/k8s/"}],"tags":[{"name":"k8s","slug":"k8s","permalink":"https://withoutcause.github.io/tags/k8s/"}]},{"title":"自学k8s系列~01之k8s是什么","slug":"自学k8s系列-01之k8s是什么","date":"2021-08-24T14:02:00.000Z","updated":"2021-08-24T14:02:00.000Z","comments":true,"path":"2021/08/24/自学k8s系列-01之k8s是什么/","link":"","permalink":"https://withoutcause.github.io/2021/08/24/%E8%87%AA%E5%AD%A6k8s%E7%B3%BB%E5%88%97-01%E4%B9%8Bk8s%E6%98%AF%E4%BB%80%E4%B9%88/","excerpt":"k8s 的logo k8s 是什么?","text":"k8s 的logo k8s 是什么?k8s 是 kubernetes 的简称， k和s之间有 8 个字母，老外的缩写就是这样。 首先，它是一个全新的基于容器技术的分布式架构领先方案。 提供众多底层模块和功能。 Kubernetes是一个开放的开发平台。 屏蔽了底层 k8s 是当前最火的一门技术，而且很多大厂都在使用。值得学习 后面再补 学习资料 《每天5分钟玩转Kubernetes》 《基于Kubernetes的容器云平台实战》 《Kubernetes进阶实战》 《Kubernetes权威指南：从Docker到Kubernetes实践全接触（第4版）》 《容器云运维实战：Docker与Kubernetes集群》 《精通Kubernetes》 caicloud/kube-ladder: Learning Kubernetes, The Chinese Taoist Way (github.com)","categories":[{"name":"k8s","slug":"k8s","permalink":"https://withoutcause.github.io/categories/k8s/"}],"tags":[{"name":"k8s","slug":"k8s","permalink":"https://withoutcause.github.io/tags/k8s/"}]},{"title":"自学k8s系列~00之目录","slug":"自学k8s系列-00之目录","date":"2021-08-24T14:00:00.000Z","updated":"2021-08-24T14:00:00.000Z","comments":true,"path":"2021/08/24/自学k8s系列-00之目录/","link":"","permalink":"https://withoutcause.github.io/2021/08/24/%E8%87%AA%E5%AD%A6k8s%E7%B3%BB%E5%88%97-00%E4%B9%8B%E7%9B%AE%E5%BD%95/","excerpt":"自学k8s系列-01之k8s是什么 自学k8s系列-02之k8s主要概念 自学k8s系列-03之YAML","text":"自学k8s系列-01之k8s是什么 自学k8s系列-02之k8s主要概念 自学k8s系列-03之YAML 自学k8s系列-04之Pod 自学k8s系列-05之Service 自学k8s系列~06之滚动更新","categories":[{"name":"k8s","slug":"k8s","permalink":"https://withoutcause.github.io/categories/k8s/"}],"tags":[{"name":"k8s","slug":"k8s","permalink":"https://withoutcause.github.io/tags/k8s/"}]},{"title":"踩坑记录","slug":"踩坑记录","date":"2021-08-24T13:47:53.000Z","updated":"2021-08-24T13:47:53.000Z","comments":true,"path":"2021/08/24/踩坑记录/","link":"","permalink":"https://withoutcause.github.io/2021/08/24/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/","excerpt":"IDEA 编译OOM现象fms 工程在编译时，抛出 OOM 异常，使用 Maven 编译是正常的。在编译过程中发现两个问题。","text":"IDEA 编译OOM现象fms 工程在编译时，抛出 OOM 异常，使用 Maven 编译是正常的。在编译过程中发现两个问题。 除了 javac 编译外，还在使用 kotlin 编译 系统剩余内存足够，使用 Maven 编译的 war 包可以在 tomcat 中正常启动。 原因IDEA 可以设置编译时的堆(HEAP)大小，默认值是 700(MBytes) ,一般的工程也足够但是 fms 不够，超过了 700(MBytes) 就报 OOM。 解决办法 在 IDEA 中设置编译时的堆大小。 泛型擦除现象在 doraemon-fs 中写了 spring 的 bean，然后增加了一个配置类，在配置类中使用 @ComponentScan 注解配置对扫描的包名，在写了一个 @EnableFsQuery 注解，在 mdm 启动类上打注解 @EnableFsQuery，mdm 启动时无法注入指定的 bean。 123@Import(FsMongoConfig.class)public @interface EnableFsQuery &#123;&#125; 原因@EnableFsQuery 注解上没有打生命周期对应的注解。泛型的默认 RetentionPolicy.CLASS ，在运行期间不保留注解。 解决办法12345@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Import(FsMongoConfig.class)public @interface EnableFsQuery &#123;&#125; 自定义切面启动异常现象Spring 启动报异常: 1:0 can&#x27;t find referenced pointcut 原因AspectJ 依赖包 aspectjweaver 版本过低导致。 解决办法升级依赖包 12345&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.8&lt;/version&gt;&lt;/dependency&gt;","categories":[{"name":"踩过的坑","slug":"踩过的坑","permalink":"https://withoutcause.github.io/categories/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://withoutcause.github.io/tags/IDEA/"},{"name":"踩坑","slug":"踩坑","permalink":"https://withoutcause.github.io/tags/%E8%B8%A9%E5%9D%91/"},{"name":"泛型擦除","slug":"泛型擦除","permalink":"https://withoutcause.github.io/tags/%E6%B3%9B%E5%9E%8B%E6%93%A6%E9%99%A4/"}]},{"title":"git hooks——commit message 校验","slug":"git-hooks——commit-message-校验","date":"2021-08-23T07:29:01.000Z","updated":"2021-08-23T07:29:01.000Z","comments":true,"path":"2021/08/23/git-hooks——commit-message-校验/","link":"","permalink":"https://withoutcause.github.io/2021/08/23/git-hooks%E2%80%94%E2%80%94commit-message-%E6%A0%A1%E9%AA%8C/","excerpt":"git是现在最流行的版本控制工具，书写良好的commit message能大大提高代码维护的效率。但是在日常开发中由于缺少对于commit message的约束，导致填写内容随意、质量参差不齐，可读性低亦难以维护。在项目中引入commit message规范已是迫在眉睫。 提交规范 源于 Angular 规范 提交格式 &lt;type&gt;(&lt;scope&gt;): &lt;subject&gt; commit message 示例: 1feat(数据中心): HS001 增加订单列表 type 选项 feat：新功能（feature） fix：修补bug docs：文档（documentation） style： 格式（不影响代码运行的变动） refactor：重构（即不是新增功能，也不是修改bug的代码变动） test：增加测试 chore：构建过程或辅助工具的变动 perf: 性能提升变更 ci : 持续集成变更 build ： 代码构建变更 temp ： 临时代码 scope 变更范围(粒度较小，并在一想 项目中保持一致)：例如页面名称、模块名称、组件名称…… subject 简短的描述","text":"git是现在最流行的版本控制工具，书写良好的commit message能大大提高代码维护的效率。但是在日常开发中由于缺少对于commit message的约束，导致填写内容随意、质量参差不齐，可读性低亦难以维护。在项目中引入commit message规范已是迫在眉睫。 提交规范 源于 Angular 规范 提交格式 &lt;type&gt;(&lt;scope&gt;): &lt;subject&gt; commit message 示例: 1feat(数据中心): HS001 增加订单列表 type 选项 feat：新功能（feature） fix：修补bug docs：文档（documentation） style： 格式（不影响代码运行的变动） refactor：重构（即不是新增功能，也不是修改bug的代码变动） test：增加测试 chore：构建过程或辅助工具的变动 perf: 性能提升变更 ci : 持续集成变更 build ： 代码构建变更 temp ： 临时代码 scope 变更范围(粒度较小，并在一想 项目中保持一致)：例如页面名称、模块名称、组件名称…… subject 简短的描述 添加 hook 在目前添加在本地的 git hook 中，校验阶段是 commit-msg 阶段。脚本内容如下: 1234567891011121314151617181920#!/bin/shmsg=`awk &#x27;&#123;printf(&quot;%s&quot;,$0)&#125;&#x27; $1`# Merge 的时候，会自动生成 Commit Message, 长成这样的: Merge branch &#x27;master&#x27; into test-abc, 这种跳过mergePatten=&#x27;^Merge &#x27;if [[ $msg =~ $mergePatten ]]; then echo &quot;😁😁😁合并分支自动生成的 CommitMessage, 跳过!&quot; exit 0fi# 非 Merge 开头的，认为是手动提交的信息，需要遵循这种格式patten=&#x27;^(feat|fix|test|refactor|docs|style|chroe)\\(.*\\):.*$&#x27;if [[ $msg =~ $patten ]]; then echo &quot;😁😁😁太棒了!&quot;else echo &quot;😭😭😭 兄弟，别瞎搞提交的 message 格式不对&quot; echo &quot;提交参考格式: &lt;类型&gt;[可选的作用域]: &lt;描述&gt;&quot; exit 1fi 添加目录 将上面的脚本保存成 commit-msg 文件，然后进行以下操作。 工程.git 目录 -&gt; hooks -&gt; commit-msg hooks 目录中会存在 commit-msg.sample，这是 git 的 hook 参考文件。 全局添加如果每个工程的 .git 目录下的 hooks 都添加一遍会过于繁琐，使用全局的会很省事(可选)。 在 home 目录下创建 .git_hook 目录 1mkdir ~/.git_hooks 复制 commit-msg 文件到上面创建的 .git_hook 目录下 1cp comit-msg /.git_hooks 全局添加该脚本 1git config --global core.hooksPath ~/.git_hooks","categories":[{"name":"git","slug":"git","permalink":"https://withoutcause.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://withoutcause.github.io/tags/git/"},{"name":"hook","slug":"hook","permalink":"https://withoutcause.github.io/tags/hook/"}]},{"title":"Linux Shell","slug":"Linux-Shell","date":"2021-08-23T07:00:05.000Z","updated":"2021-08-23T07:00:05.000Z","comments":true,"path":"2021/08/23/Linux-Shell/","link":"","permalink":"https://withoutcause.github.io/2021/08/23/Linux-Shell/","excerpt":"最近在组内推 git 提交规范，使用到了 shell 脚本，对一些内容再学习了一遍，做一个笔记。 Shell 的格式1#!/bin/bash","text":"最近在组内推 git 提交规范，使用到了 shell 脚本，对一些内容再学习了一遍，做一个笔记。 Shell 的格式1#!/bin/bash","categories":[{"name":"Linux","slug":"Linux","permalink":"https://withoutcause.github.io/categories/Linux/"},{"name":"Shell","slug":"Linux/Shell","permalink":"https://withoutcause.github.io/categories/Linux/Shell/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://withoutcause.github.io/tags/Linux/"},{"name":"Shell","slug":"Shell","permalink":"https://withoutcause.github.io/tags/Shell/"}]},{"title":"流量回放","slug":"流量回放","date":"2021-08-23T03:19:06.000Z","updated":"2021-08-23T03:19:06.000Z","comments":true,"path":"2021/08/23/流量回放/","link":"","permalink":"https://withoutcause.github.io/2021/08/23/%E6%B5%81%E9%87%8F%E5%9B%9E%E6%94%BE/","excerpt":"","text":"看了群里讨论的问题，也是我一直在考虑如何解决的问题，这里做个梳理和总结，希望能在梳理的基础上理清思路，统一问题难点，希望有能力，有想法的同学能够更有针对性的提出解决方案首先，将流量回放进行分类，无非就是读和写两大类：读流量：处理起来比较简单，录制好后直接回放即可（注意是相同环境回放，或相同数据库基础上，如果是线上录制，可以直接在灰度或预发环境回放），总结下来读流量的特点是： 1. 不用担心数据没有准备好（因为录制时已经创建好了） a. 问题：如果是不同环境，或影子库，就要考虑数据准备的问题 2. 也不用担心污染（只是读） 3. 可以重复回放（请求是幂等的） 写流量：与读流量的特点相反，读流量回放的优势，正是写流量回放的难点 1. 写流量本身就可以看做是准备数据的过程 a. 问题：写入新的数据后，如何通知到下游 2. 要么写入失败，要么产生新的数据（脏数据，产生污染，写影子库是一种解法） a. 如创建用户，相同姓名和身份证号的，只能有一个，再次创建就会失败 b. 如创建订单，每次都生成新的订单号，问题同1.a是这个新生成的订单号，如何通知下游 3. 关于写接口的重复回放 a. 同2.a如果是写接口是在参数相同的情况下是排他的，则不能重复回放 b. 同2.b创建订单类的可以重复回放，但是一是会产生很多脏数据，二是如何通知下游 总结一下问题和群里讨论的解决方案： 1. 读流量的数据如何准备？ 解1：人工介入，提前准备，回放时读取配置进行替换 解2：录制时也包括写流量，回放时也回放写流量，但是要提取写流程的出参，放入环境变量或本次回放的局部变量中，供下游接口在需要时进行替换 总的来说这两种解法都是一样的，就是数据偏移，个人感觉这也是柯南开源的一个亮点，提出了数据偏移的概念（当然具体实现是什么相的我还不清楚，但我个人觉得这个指明了解决问题的方向，让我们在解决这个问题上不再迷茫） 2. 写流量产生的响应出参，如何通知下游进行替换？ 基于我个人对流量回放的思考和理解，我知道替换是必须要做的，具体怎么做，有一点思路，但是也没有实践过，希望柯南开源的大佬，能讲讲这部分是如何做到的？ 3. 3.1 排他性的写流量，如何做到重复回放时不失败报错？ 当然，这个问题的答案，最终也得回到偏移替换上，对入参进行偏移替换就可以了吗？如何做到，同问题2，希望有大佬回答下。 3.2 脏数据的问题，如何避免污染？ 回答可能是影子库。但是从群内的讨论来看，好像意思是，在回放的时候写的流量可以写到影子库，但是读的流量，仍然可以读正式库。（请柯南的大佬确认一下，可以这么做吗？）这么做似乎没有什么问题，但是个人认为读写还是保持连贯比较高，即写在哪里，读就在哪里。 另外，多说一句，有人可能会问，重复回放失败的问题，写影子库不也就解决了吗？我之所以在3.1时没提影子库，就是因为这个问题不是影子库能解决的，因为一旦在影子库回放过一次之后，影子库里也就有相同的数据了，再次回放肯定还是会报错的。 这里再引申一下，其实关于重复写的问题我跟同事讨论过，他提出了一个很大胆的想法，即影子库镜像，即在流量录制前，将影子库做成镜像，每次流量回放时，将镜像库还原，这样做的话，可以做到录制流量一丝一毫修改都不需要帮，100%真实流量回放。我觉得这个想法很有创意，至于实践起来会遇到什么样的困难，大家可以思考一下，我这里就算抛转引玉了。 另外，总结了这么多，一直没有提到mock，这里再追加一下写流量的另外一种解法：即采用mock，如果是用jvm-sandbox-repeater做流量回放的话，可以做到方法级别的mock，即遇到写库的操作，并不真的执行写入操作，可以mock为返回指定的数据。仔细想想，如果采用mock的话即不用写影子库，又不用考虑数据偏移，真是个好东西，对于服务端是java应用来说，是个不错的选择。（当然，通用性有一定的限制，必须是java应用，另外，对于mock针对其他数据源的支持情况还有待考证，如ES，hbase，redis等）","categories":[{"name":"流量回放","slug":"流量回放","permalink":"https://withoutcause.github.io/categories/%E6%B5%81%E9%87%8F%E5%9B%9E%E6%94%BE/"}],"tags":[{"name":"流量回放","slug":"流量回放","permalink":"https://withoutcause.github.io/tags/%E6%B5%81%E9%87%8F%E5%9B%9E%E6%94%BE/"}]},{"title":"ChannelHandler事件","slug":"ChannelHandler事件","date":"2021-08-11T11:55:30.000Z","updated":"2021-08-11T11:55:30.000Z","comments":true,"path":"2021/08/11/ChannelHandler事件/","link":"","permalink":"https://withoutcause.github.io/2021/08/11/ChannelHandler%E4%BA%8B%E4%BB%B6/","excerpt":"ChannelHandlerChannelInboundHandlerchannelInBoundHandler 事件, 具体可以看 io.netty.channel.ChannelInboundHandler 接口的方法。","text":"ChannelHandlerChannelInboundHandlerchannelInBoundHandler 事件, 具体可以看 io.netty.channel.ChannelInboundHandler 接口的方法。 事件回调方法 触发时机 channelRegistered Channel 被注册到 EventLoop channelUnReistered Channel 从 EventLoop 上取消注册 channelActive Channel 被激活，处于就绪状态，可以被读写 channelInActive Channel 处于非就绪状态，可以从远端读取到数据 channelRead Channel 可以从远端读取到数据 channelReadComplate Channel 从远端读取数据完成 userEventTriggered 用户事件被触发时 channelWritabilityChanged Channel 的写状态发生变化 ChannelOutboundHandler 事件回调方法 触发时机 bind 监听地址(IP + 端口)绑定(用于服务端) connect 连接服务器(用于客户端) disconnect 断开服务器连接 close 主动关闭 Channel deregister read 读数据 write 定局数据 flush 刷数据 ChannelInitializer装配 handler 123456789server.childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123; @Override protected void initChannel(NioSocketChannel nioSocketChannel) throws Exception &#123; nioSocketChannel.pipeline() .addLast(new StringDecoder()) .addLast(new StringEncoder()) .addLast(handler); &#125; &#125;); 在 initChannel 方法中装配各种 handler 以实现自己的业务逻辑。 事件回调ChannelHandler 的调用顺序。","categories":[{"name":"Netty","slug":"Netty","permalink":"https://withoutcause.github.io/categories/Netty/"}],"tags":[{"name":"Netty","slug":"Netty","permalink":"https://withoutcause.github.io/tags/Netty/"}]},{"title":"IDEA快捷键","slug":"IDEA快捷键","date":"2021-08-05T11:30:53.000Z","updated":"2021-08-05T11:30:53.000Z","comments":true,"path":"2021/08/05/IDEA快捷键/","link":"","permalink":"https://withoutcause.github.io/2021/08/05/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE/","excerpt":"Mac键盘符号和修饰键说明 ⇞ Page Up（Fn+↑） ⇟ Page Down（Fn+↓） Home Fn + ← End Fn + → Editing（编辑）","text":"Mac键盘符号和修饰键说明 ⇞ Page Up（Fn+↑） ⇟ Page Down（Fn+↓） Home Fn + ← End Fn + → Editing（编辑） Command + Shift + Enter 自动结束代码，行末自动添加分号 Command + P 显示方法的参数信息 Control + J, Mid. button click 快速查看文档 Shift + F1 查看外部文档（在某些代码上会触发打开浏览器显示相关文档） Command + +鼠标放在代码上 显示代码简要信息 Command + F1 在错误或警告处显示具体描述信息 Command + N, Control + Enter, Control + N 生成代码（getter、setter、构造函数、hashCode/equals,toString） Control + O 覆盖方法（重写父类方法） Control + I 实现方法（实现接口中的方法） Command + OptionT 包围代码（使用iF..else, try..catch, For, synchronized等包围选中的代码） Command + / 注释/取消注释与行注释 Command + Option/ 注释/取消注释与块注释 Option + ↑ 连续选中代码块 Option + ↓ 减少当前选中的代码块 Control + Shift + Q 显示上下文信息 OptionEnter 显示意向动作和快速修复代码 Command + Option + L 格式化代码 Control + Option + O 优化import Control + Option + I 自动缩进线 Tab / Shift + Tab 缩进代码 / 反缩进代码 Command + X 剪切当前行或选定的块到剪贴板 Command + C 复制当前行或选定的块到剪贴板 Command + V 从剪贴板粘贴 Command + Shift + V 从最近的缓冲区粘贴 Command + D 复制当前行或选定的块 Command + Delete 删除当前行或选定的块的行 Control + Shift + J 智能的将代码拼接成一行 Command + Enter 智能的拆分拼接的行 Shift + Enter 开始新的一行 Command + Shift + U 大小写切换 Command + Shift + ] / Command + Shift + [ 切换 Tab 页 OptionFn + Delete 删除到单词的末尾（Fn + Delete键为Fn+Delete） Option + Delete 删除到单词的开头 Command + +/Command + - 展开 / 折叠代码块 Command + Shift + + 展开所以代码块 Command + Shift + - 折叠所有代码块 Command + W 关闭活动的编辑器选项卡 Command+Y 查看选中当前源码 Search/Replace（查询/替换） Double Shift (连按两下 Shift) 查询任何东西 Command + F 文件内查找 Command + G 查找模式下，向下查找 Command + Shift + G 查找模式下，向上查找 Command + R 文件内替换 Command + Shift + F 全局查找（根据路径） Command + Shift + R 全局替换（根据路径） Command + Shift + M 替换结构（Ultimate Edition 版专用，需要在Keymap中设置） Usage Search（使用查询） OptionF7 / Command + F7 在文件中查找用法 / 在类中查找用法 Command + Shift + F7 在文件中突出显示的用法 Command + OptionF7 显示用法 Compile and Run（编译和运行） Command + F9 编译Project Command + Shift + F9 编译选择的文件、包或模块 Control + Option + R 弹出 Run 的可选择菜单 Control + Option + D 弹出 Debug 的可选择菜单 Control + R 运行 Control + D 调试 Control + Shift + R, Control + Shift + D 从编辑器运行上下文环境配置 Debugging（调试） F8 进入下一步，如果当前行断点是一个方法，则不进入当前方法体内 F7 进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中 Shift + F7 智能步入，断点所在行上有多个方法调用，会弹出进入哪个方法 Shift + F8 跳出 Option + F9 运行到光标处，如果光标前有其他断点会进入到该断点 Option + F8 计算表达式（可以更改变量值使其生效） Command + OptionR 恢复程序运行，如果该断点下面代码还有断点则停在下一个断点上 Command + F8 切换断点（若光标当前行有断点则取消断点，没有则加上断点） Command + Shift + F8 查看断点信息 Navigation（导航） Command + O 查找类文件 Command + Shift + O 查找所有类型文件、打开文件、打开目录，打开目录需要在输入的内容前面或后面加一个反斜杠/ Command + OptionO 前往指定的变量 / 方法 Control + ← / Control + → 左右切换打开的编辑tab页 F12 返回到前一个工具窗口 Esc 从工具窗口进入代码文件窗口 Shift + Esc 隐藏当前或最后一个活动的窗口，且光标进入代码文件窗口 Command + Shift + F4 关闭活动run/messages/Find/… tab Command + L 在当前文件跳转到某一行的指定处 Command + E 显示最近打开的文件记录列表 Command + Option + ← / Command + Option + → 退回 / 前进到上一个操作的地方 Command + Shift + Delete 跳转到最后一个编辑的地方 Option + F1 显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择(如在代码编辑窗口可以选择显示该文件的Finder) Command + B / Command + 鼠标点击 进入光标所在的方法/变量的接口或是定义处 Command + Option + B 跳转到实现处，在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口 Command + Y 快速打开光标所在方法、类的定义 Control + Shift + B 跳转到类型声明处 Command + U 前往当前光标所在方法的父类的方法 / 接口定义 Control + ↓ / Control + ↑ 当前光标跳转到当前文件的前一个/后一个方法名位置 Command + ] / Command + [ 移动光标到当前所在代码的花括号开始/结束位置 Command + F12 弹出当前文件结构层，可以在弹出的层上直接输入进行筛选（可用于搜索类中的方法） Control + H 显示当前类的层次结构 Command + Shift + H 显示方法层次结构 Control + OptionH 显示调用层次结构 F2 / Shift + F2 跳转到下一个/上一个突出错误或警告的位置 F4 / Command + ↓ 编辑/查看代码源 Option Home 显示到当前文件的导航条 F3选中文件/文件夹/代码行，添加/取消书签 Option + F3 选中文件/文件夹/代码行，使用助记符添加/取消书签 Control + 0...Control + 9 定位到对应数值的书签位置 Command + F3 显示所有书签 ReFactoring（重构） F5 复制文件到指定目录 F6 移动文件到指定目录 Command + Delete 在文件上为安全删除文件，弹出确认框 Shift + F6 重命名文件 Command + F6 更改签名 Command + Option + N 一致性 Command + Option + M 将选中的代码提取为方法 Command + Option + V 提取变量 Command + Option + F 提取字段 Command + Option + C 提取常量 Command + Option +P 提取参数 VCS/Local History（版本控制/本地历史记录） Control + 9 快速弹出版本控制器操作面板 Command + K 提交代码到版本控制器 Command + T 从版本控制器更新代码 Option + Shift + C 查看最近的变更记录 Live Templates（动态代码模板） Command + Option + J 弹出模板选择窗口，将选定的代码使用动态模板包住 Command + J 插入自定义动态代码模板 General（通用） Command + 1...Command + 9 打开相应编号的工具窗口 Command + S 保存所有 Command + OptionY 同步、刷新 Control + Command + F 切换全屏模式 Command + Shift + F12 切换最大化编辑器 Option + Shift + F 添加到收藏夹 Option + Shift + I 检查当前文件与当前的配置文件 Control + ` 快速切换当前的scheme（切换主题、代码样式等） Command + , 打开IDEA系统设置 Command + ; 打开项目结构对话框 Shift + Command + A 查找动作（可设置相关选项） Control + Tab 编辑窗口标签和工具窗口之间切换（如果在切换的过程加按上delete，则是关闭对应选中的窗口） Other（一些官方文档上没有体现的快捷键） Command + Shift + 8 竖编辑模式 Command + Shift + A 查找动作 Alt + F1 快捷选择 Command + Option+F7 这个是查找选中的字符在工程中出现的地方，可以不是方法变量类等，这个和上面的有区别的 Command＋F7 可以查询当前元素在当前文件中的引用，然后按F3可以选择 ，功能基本同上 选中文本，按 Command + Shift + F7 ，高亮显示所有该文本，按Esc高亮消失。 Option+F7 查找变量方法使用的地方 Command + Shift + R 可以在整个工程或着某个目录下面替换变量 Control + Shift + J 把多行连接成一行，会去掉空格的行 Command + J 可以生成一些自动代码，比如For循环 Command + B 找变量的来源 同F4 查找变量来源 Control + Shift + B 找变量所属的类 Command + G 查找变量并且定位 Command + Shift + F 可以在整个工程或着某个目录下面查找变量 相当于eclipse里的 ctrl+H Option + Shift + C 最近修改的文件 Command + Option+L 格式化代码 Command + Shift + enter 代码补全，这个会判断可能用到的，这个代码补全和代码提示是不一样的 Command + Option+T 把选中的代码放在 TRY{} IF{} ELSE{} 里 Command + Option+/ 注释/…/ Command + Option+左右箭头 返回上次编辑的位置 Command + 左右箭头 返回最左边最右边 Command + Shift + 上下箭头 把代码上移或着下移 Command + F12 可以显示当前文件的结构","categories":[{"name":"IDEA","slug":"IDEA","permalink":"https://withoutcause.github.io/categories/IDEA/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://withoutcause.github.io/tags/IDEA/"}]},{"title":"MapStruct实用","slug":"MapStruct实用","date":"2021-08-02T15:46:16.000Z","updated":"2021-08-02T15:46:16.000Z","comments":true,"path":"2021/08/02/MapStruct实用/","link":"","permalink":"https://withoutcause.github.io/2021/08/02/MapStruct%E5%AE%9E%E7%94%A8/","excerpt":"Maven 依赖在 pom.xml 中加入以下依赖 1234567891011121314151617181920212223242526272829303132&lt;properties&gt; &lt;org.mapstruct.version&gt;1.4.2.Final&lt;/org.mapstruct.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct&lt;/artifactId&gt; &lt;version&gt;$&#123;org.mapstruct.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;annotationProcessorPaths&gt; &lt;path&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct-processor&lt;/artifactId&gt; &lt;version&gt;$&#123;org.mapstruct.version&#125;&lt;/version&gt; &lt;/path&gt; &lt;/annotationProcessorPaths&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt;","text":"Maven 依赖在 pom.xml 中加入以下依赖 1234567891011121314151617181920212223242526272829303132&lt;properties&gt; &lt;org.mapstruct.version&gt;1.4.2.Final&lt;/org.mapstruct.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct&lt;/artifactId&gt; &lt;version&gt;$&#123;org.mapstruct.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;annotationProcessorPaths&gt; &lt;path&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct-processor&lt;/artifactId&gt; &lt;version&gt;$&#123;org.mapstruct.version&#125;&lt;/version&gt; &lt;/path&gt; &lt;/annotationProcessorPaths&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 如果使用了 lombok 还需要再添加以下内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;properties&gt; &lt;org.mapstruct.version&gt;1.4.2.Final&lt;/org.mapstruct.version&gt; &lt;org.projectlombok.version&gt;1.18.16&lt;/org.projectlombok.version&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct&lt;/artifactId&gt; &lt;version&gt;$&#123;org.mapstruct.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;$&#123;org.projectlombok.version&#125;&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;annotationProcessorPaths&gt; &lt;path&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct-processor&lt;/artifactId&gt; &lt;version&gt;$&#123;org.mapstruct.version&#125;&lt;/version&gt; &lt;/path&gt; &lt;!-- lombok 需要添加以下内容 --&gt; &lt;path&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;$&#123;org.projectlombok.version&#125;&lt;/version&gt; &lt;/path&gt; &lt;!-- lombok 版本大于等于 1.18.16 还需要添加以下内容 --&gt; &lt;path&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok-mapstruct-binding&lt;/artifactId&gt; &lt;version&gt;0.1.0&lt;/version&gt; &lt;/path&gt; &lt;/annotationProcessorPaths&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; MapStruct 是用来做两个对象之间的映射关系，在平常的开发中，我们经常会使用到 BeanUtils 这种工具。BeanUtils 的问题在于，他对每个成员亦是赋值是通过反射来做的，并且成员变量的字段名必须一致。而 MapStruct 是在编译期完成这件事情的，还可以将不同名称，不同类型的成员变量进行赋值。 定义 Mapper在接口上打上 @Mapper 注解, MapStruct 会生成对应的接口实现。 1234@Mapperpublic interface Convert &#123;&#125; 使用 Convert普通方式(推荐)123456@Mapperpublic interface Convert &#123; Convert INSTANCE = Mappers.getMapper(Convert.class); @Mapping(source = &quot;createTime&quot;, target = &quot;createTime&quot;, dateFormat = &quot;yyyy-MM-dd&quot;) Person personDTO2Person(PersonDTO personDTO);&#125; 调用映射使用时，Convert.INSTANCE.personDTO2Person(personDTO) 即可。 Spring方式12345@Mapper(componentModel = &quot;spring&quot;)public interface PersonConvert &#123; @Mapping(source = &quot;createTime&quot;, target = &quot;createTime&quot;, dateFormat = &quot;yyyy-MM-dd&quot;) Person personDTO2Person(PersonDTO personDTO);&#125; 会检查 classpath 下是否饮食 spring 相关依赖 使用时， 用 Spring 的注解 @Autowired 注入。 @Mapping 注解source 指定源名称，即要映射的对象的名称 不能与constant 或 expression target 指定目标名称，即被映射的对象名称 constant 将目标对象赋值为指定的常量 不能与source ， defaultValue ， defaultExpression 或 expression 同时存在 dateFormat 将从 String 映射到 Date ， SimpleDateFormat 进行处理。 numberFormat 将从 Number 映射到 String , DecimalFormat 进行处理。其他类型将被忽略 expression 使用 java 表达式进行映射。 格式为: java()。例: 12@Mapping(target = &quot;name&quot;, expresession = &quot;java(new Date().getTime())&quot;)Person personDTO2Person(PersonDTO personDTO); 不能与 与source， defaultValue ， defaultExpression 和 constant 同时使用 defaultExpression 作用与 expression 类似，在 source 为 null 的时候应用。 不能与 expression ， defaultValue 或 constant ignore 指定字段忽略 defaultValue 当 source 为 null 的时候，为 target 字段指定默认值。 qualifiedByqualifiedByNameresultTypedependsOnnullValueCheckStrategynullValuePropertyMappingStrategy映射技巧相同类型相同名称的映射 直接写对应的映射方法即可，在参数和返回值分别写对象的 Bean 对象即可。 12345@Mapperpublic interface PersonConvert &#123; PersonConvert INSTANCE = Mappers.getMapper(PersonConvert.class); Person personDTO2Person(PersonDTO personDTO);&#125; 相同类型不同名称的映射 使用 @Mapping 注解标注对应的 source 和 target ，source 源对象的名称, target 目标名称。 123456@Mapperpublic interface PersonConvert &#123; PersonConvert INSTANCE = Mappers.getMapper(PersonConvert.class); @Mapping(source = &quot;createTime&quot;, target = &quot;time&quot;) Person personDTO2Person(PersonDTO personDTO);&#125; 不同类型相同名称的映射int 到 String12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@Datapublic class Person &#123; private String name; private String age; private LocalDate createTime;&#125;@Datapublic class PersonDTO &#123; private String name; private Integer age; private LocalDate createTime;&#125;@Mapperpublic interface PersonConvert &#123; PersonConvert INSTANCE = Mappers.getMapper(PersonConvert.class); Person personDTO2Person(PersonDTO personDTO);&#125;// PersonDTO 映射到 Person，age 字段在 Person 中是 String，PersonDTO 中是 Integer，直接映射即可，不用加额外的东西// 生成的代码如下：public class PersonConvertImpl implements PersonConvert &#123; @Override public Person personDTO2Person(PersonDTO personDTO) &#123; if ( personDTO == null ) &#123; return null; &#125; Person person = new Person(); person.setName( personDTO.getName() ); if ( personDTO.getAge() != null ) &#123; // 这里会自动加上转换的代码。 person.setAge( String.valueOf( personDTO.getAge() ) ); &#125; person.setCreateTime( personDTO.getCreateTime() ); return person; &#125;&#125;// 反过来映射， personDTO 中是 String, Person 中是 Integer,生成的代码如下：public class PersonConvertImpl implements PersonConvert &#123; @Override public Person personDTO2Person(PersonDTO personDTO) &#123; if ( personDTO == null ) &#123; return null; &#125; Person person = new Person(); person.setName( personDTO.getName() ); if ( personDTO.getAge() != null ) &#123; // 这里会自动加上转换的代码。 person.setAge( Integer.parseInt( personDTO.getAge() ) ); &#125; person.setCreateTime( personDTO.getCreateTime() ); return person; &#125;&#125; enum 到 String 调用对应枚举的 name() 方法，然后再 set 到对应字段。 123456789101112131415161718192021222324252627282930313233343536373839404142@Datapublic class Person &#123; private String name; private Integer age; private LocalDate createTime; private String sex;&#125;@Datapublic class Person &#123; private String name; private Integer age; private LocalDate createTime; private String sex;&#125;// 转换 Convert@Mapperpublic interface PersonConvert &#123; PersonConvert INSTANCE = Mappers.getMapper(PersonConvert.class); Person personDTO2Person(PersonDTO personDTO);&#125;// 生成的代码public class PersonConvertImpl implements PersonConvert &#123; @Override public Person personDTO2Person(PersonDTO personDTO) &#123; if ( personDTO == null ) &#123; return null; &#125; Person person = new Person(); person.setName( personDTO.getName() ); if ( personDTO.getAge() != null ) &#123; person.setAge( Integer.parseInt( personDTO.getAge() ) ); &#125; person.setCreateTime( personDTO.getCreateTime() ); if ( personDTO.getSex() != null ) &#123; person.setSex( personDTO.getSex().name() ); &#125; return person; &#125;&#125; 思考:如果是枚举中的某个字段，例如: 123456789@Getterpublic enum SexEnum &#123; MAN(1), WOMAN(0); private int sex; SexEnum(int sex) &#123; this.sex = sex; &#125;&#125; 其中的数字要映射到对应的对象如何转换？ Person 定义如下: 123456789@Datapublic class Person &#123; private String name; private Integer age; private LocalDate createTime; // 1-男，0-女 private Integer sex;&#125; 反过来呢？ 0/1 映射成对应的枚举。 BigDecimal 到 String 将数字进行格式化处理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@Datapublic class PersonDTO &#123; private String name; private String age; private LocalDate createTime; private SexEnum sex; private BigDecimal power;&#125;@Datapublic class Person &#123; private String name; private Integer age; private LocalDate createTime; private String sex; private String power;&#125;// 映射 Convert@Mapperpublic interface PersonConvert &#123; PersonConvert INSTANCE = Mappers.getMapper(PersonConvert.class); @Mapping(target = &quot;power&quot;, source = &quot;power&quot;, numberFormat = &quot;#.##E0&quot;) Person personDTO2Person(PersonDTO personDTO);&#125;// 生成的代码，使用 DecimalFormat 进行格式化处理public class PersonConvertImpl implements PersonConvert &#123; @Override public Person personDTO2Person(PersonDTO personDTO) &#123; if ( personDTO == null ) &#123; return null; &#125; Person person = new Person(); if ( personDTO.getPower() != null ) &#123; person.setPower( createDecimalFormat( &quot;#.##E0&quot; ).format( personDTO.getPower() ) ); &#125; person.setName( personDTO.getName() ); if ( personDTO.getAge() != null ) &#123; person.setAge( Integer.parseInt( personDTO.getAge() ) ); &#125; person.setCreateTime( personDTO.getCreateTime() ); if ( personDTO.getSex() != null ) &#123; person.setSex( personDTO.getSex().name() ); &#125; return person; &#125; private DecimalFormat createDecimalFormat( String numberFormat ) &#123; DecimalFormat df = new DecimalFormat( numberFormat ); df.setParseBigDecimal( true ); return df; &#125;&#125; Date 到 String 支持 Date 、Calendar、LocalDate、Instant、ZonedDateTime、LocalDateTime 等多种类型 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Datapublic class PersonDTO &#123; private String name; private String age; private LocalDate createTime; private SexEnum sex;&#125;@Datapublic class Person &#123; private String name; private Integer age; private String createTime; private String sex;&#125;// 映射的 Convert，@Mapperpublic interface PersonConvert &#123; PersonConvert INSTANCE = Mappers.getMapper(PersonConvert.class); @Mapping(target = &quot;createTime&quot;, source = &quot;createTime&quot;, dateFormat = &quot;yyyy-MM-dd HH:mm:ss&quot;) Person personDTO2Person(PersonDTO personDTO);&#125;// 生成的代码， 使用 DateTimeFormatter 进行格式，如果是 Date 会使用 SimpleDateFormt 进行格式化。public class PersonConvertImpl implements PersonConvert &#123; @Override public Person personDTO2Person(PersonDTO personDTO) &#123; if ( personDTO == null ) &#123; return null; &#125; Person person = new Person(); if ( personDTO.getCreateTime() != null ) &#123; person.setCreateTime( DateTimeFormatter.ofPattern( &quot;yyyy-MM-dd HH:mm:ss&quot; ).format( personDTO.getCreateTime() ) ); &#125; person.setName( personDTO.getName() ); if ( personDTO.getAge() != null ) &#123; person.setAge( Integer.parseInt( personDTO.getAge() ) ); &#125; if ( personDTO.getSex() != null ) &#123; person.setSex( personDTO.getSex().name() ); &#125; return person; &#125;&#125; 不同类型不同名称的映射 需要在 @Mapping 注解的 target 中指定目标名称。 1234567@Mapperpublic interface PersonConvert &#123; PersonConvert INSTANCE = Mappers.getMapper(PersonConvert.class); @Mapping(source = &quot;createTime&quot;, target = &quot;time&quot;, dateFormat = &quot;yyyy-MM-dd HH:mm:ss&quot;) Person personDTO2Person(PersonDTO personDTO);&#125; 多个同名参数的成员变量 在转换的方法中有多个参数，参数为 DTO 对象，多个对象可能会出现重名的情况。例如: 12345678910111213141516@Datapublic class PersonDTO &#123; private String name;&#125;@Datapublic class UserDTO &#123; private String name;&#125;// 映射后的对象， userDTO.name -&gt; nickname; personDTO.name -&gt; name;@Datapublic class Person &#123; private String name; private String nickName;&#125; 映射时需要指定映射的名称 123456789101112131415161718192021222324252627@Mapperpublic interface PersonConvert &#123; PersonConvert INSTANCE = Mappers.getMapper(PersonConvert.class); @Mapping(source = &quot;userDTO.name&quot;, target = &quot;nickName&quot;) @Mapping(source = &quot;personDTO.name&quot;, target = &quot;name&quot;) Person personDTOUSer2Person(PersonDTO personDTO, UserDTO userDTO);&#125;// 生成的代码public class PersonConvertImpl implements PersonConvert &#123; @Override public Person personDTOUSer2Person(PersonDTO personDTO, UserDTO userDTO) &#123; if ( personDTO == null &amp;&amp; userDTO == null ) &#123; return null; &#125; Person person = new Person(); if ( personDTO != null ) &#123; person.setName( personDTO.getName() ); &#125; if ( userDTO != null ) &#123; person.setNickName( userDTO.getName() ); &#125; return person; &#125;&#125; 在参数上映射而不返回值 上面的映射全都是把参数映射成对应的返回值，我们接收到的返回值是映射后的对象。这里的问题是，返回对象是新 new 的，如果我们已经存在一个对象，映射部分字段想要传入一个已经手动 new 好的对象来映射。 使用 @MappingTarget 来标记返回的对象。 12345678910111213141516171819202122232425262728293031323334353637383940@Datapublic class PersonDTO &#123; private String name;&#125;@Datapublic class UserDTO &#123; private String name;&#125;@Datapublic class Person &#123; private String name; private String nickName;&#125;@Mapperpublic interface PersonConvert &#123; PersonConvert INSTANCE = Mappers.getMapper(PersonConvert.class); @Mapping(source = &quot;userDTO.name&quot;, target = &quot;nickName&quot;) @Mapping(source = &quot;personDTO.name&quot;, target = &quot;name&quot;) void personDTOUSer2Person(PersonDTO personDTO, UserDTO userDTO, @MappingTarget Person person);&#125;// 生成的代码public class PersonConvertImpl implements PersonConvert &#123; @Override public void personDTOUSer2Person(PersonDTO personDTO, UserDTO userDTO, Person person) &#123; if ( personDTO == null &amp;&amp; userDTO == null ) &#123; return; &#125; if ( personDTO != null ) &#123; person.setName( personDTO.getName() ); &#125; if ( userDTO != null ) &#123; person.setNickName( userDTO.getName() ); &#125; &#125;&#125; 成员变量直接映射 即没有 get 和 set 方法，而是直接使用 public 定义的成员变量 123456789101112131415161718192021222324252627282930public class PersonDTO &#123; public String name; public Integer age;&#125;public class Person &#123; public String name; public Integer age;&#125;// 映射@Mapperpublic interface PersonConvert &#123; PersonConvert INSTANCE = Mappers.getMapper(PersonConvert.class); Person personDTOUSer2Person(PersonDTO personDTO);&#125;// 生成的代码public class PersonConvertImpl implements PersonConvert &#123; @Override public Person personDTOUSer2Person(PersonDTO personDTO) &#123; if ( personDTO == null ) &#123; return null; &#125; Person person = new Person(); person.name = personDTO.name; person.age = personDTO.age; return person; &#125;&#125; 嵌套的 Bean 映射 对象中有多层嵌套 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061@Datapublic class PersonDTO &#123; private String name; private Integer age; private Record record; @Data public static class Record &#123; private String recordName; private Integer number; &#125;&#125;@Datapublic class Person &#123; private String personName; private Integer age; private Integer account;&#125;// 将 PersonDTO 中的 name 映射为 personName// age 映射为 age// Record 中的 number 映射为 Person 中的 account@Mapperpublic interface PersonConvert &#123; PersonConvert INSTANCE = Mappers.getMapper(PersonConvert.class); @Mapping(source = &quot;record.number&quot;, target = &quot;account&quot;) @Mapping(source = &quot;name&quot;, target = &quot;personName&quot;) Person personDTOUSer2Person(PersonDTO personDTO);&#125;// 生成的代码public class PersonConvertImpl implements PersonConvert &#123; @Override public Person personDTOUSer2Person(PersonDTO personDTO) &#123; if ( personDTO == null ) &#123; return null; &#125; Person person = new Person(); person.setAccount( personDTORecordNumber( personDTO ) ); person.setPersonName( personDTO.getName() ); person.setAge( personDTO.getAge() ); return person; &#125; private Integer personDTORecordNumber(PersonDTO personDTO) &#123; if ( personDTO == null ) &#123; return null; &#125; Record record = personDTO.getRecord(); if ( record == null ) &#123; return null; &#125; Integer number = record.getNumber(); if ( number == null ) &#123; return null; &#125; return number; &#125;&#125; Builder 模式映射 被映射代码是基于 Builder 模式设计的 12345678910111213141516171819202122232425262728293031@Datapublic class PersonDTO &#123; private String name; private Integer age;&#125;@Builderpublic class Person &#123; private String name; private Integer age;&#125;// 映射器@Mapperpublic interface PersonConvert &#123; PersonConvert INSTANCE = Mappers.getMapper(PersonConvert.class); Person personDTOUSer2Person(PersonDTO personDTO);&#125;// 生成的映射器代码public class PersonConvertImpl implements PersonConvert &#123; @Override public Person personDTOUSer2Person(PersonDTO personDTO) &#123; if ( personDTO == null ) &#123; return null; &#125; PersonBuilder person = Person.builder(); person.name( personDTO.getName() ); person.age( personDTO.getAge() ); return person.build(); &#125;&#125; 构造器映射 只有一个公共的构造器 有一个 @Default 注解，可以来自任何包。 有一个无参构造器，同时还包含其他构造器。 有多个公共构造器，不含无参构造器，（编译错误）。 1234567891011121314151617@Getter@AllArgsConstructorpublic class PersonDTO &#123; private String name; private Integer age;&#125;@Getter@AllArgsConstructorpublic class Person &#123; private String name; private Integer age;&#125; 只有一个公共的构造器1 集合映射Map映射其他用法向映射器添加自定义方法 在接口中写一个 default 方法即可，这其实就是自己手动写个方法。**(很少会用)** 1234567891011121314@Mapperpublic interface PersonConvert &#123; PersonConvert INSTANCE = Mappers.getMapper(PersonConvert.class); @Mapping(source = &quot;createTime&quot;, target = &quot;createTime&quot;, dateFormat = &quot;yyyy-MM-dd&quot;) Person personDTO2Person(PersonDTO personDTO); default PersonDTO person2PersonDTO(Person person) &#123; PersonDTO dto = new PersonDTO(); dto.setName(&quot;张三&quot;); dto.setAge(person.getAge() + 13); dto.setCreateTime(&quot;这个时间很奇怪，我必须手动实现&quot;); return dto; &#125;&#125; 在抽象类中实现。也是一样写一个 public 的方法即可，Mapstruct 的实现是，继承我们自己写的那个抽象类。(基本不用)","categories":[{"name":"MapStruct","slug":"MapStruct","permalink":"https://withoutcause.github.io/categories/MapStruct/"}],"tags":[{"name":"MapStruct","slug":"MapStruct","permalink":"https://withoutcause.github.io/tags/MapStruct/"}]},{"title":"Netty之IM初试","slug":"Netty之IM初试","date":"2021-08-02T15:27:59.000Z","updated":"2021-08-02T15:27:59.000Z","comments":true,"path":"2021/08/02/Netty之IM初试/","link":"","permalink":"https://withoutcause.github.io/2021/08/02/Netty%E4%B9%8BIM%E5%88%9D%E8%AF%95/","excerpt":"规划Netty 最主要的功能就是网络编程，在学习 Netty 的过程中，我准备一边学一边完善一个小的学习项目。这是一个简单的 Demo级 的 IM 案例，要实现的东西也不多，主要包含以下功能: 一个服务端和两个客户端(同一台机器上) 客户端从控制台发送任务消息，服务端原样在控制台打印该消息，要对两个客户端分开进行标记。 服务端发送消息，所有客户端都能统一接收（单聊）。 服务端可以指定单独某一个客户端接收消息（群发）。","text":"规划Netty 最主要的功能就是网络编程，在学习 Netty 的过程中，我准备一边学一边完善一个小的学习项目。这是一个简单的 Demo级 的 IM 案例，要实现的东西也不多，主要包含以下功能: 一个服务端和两个客户端(同一台机器上) 客户端从控制台发送任务消息，服务端原样在控制台打印该消息，要对两个客户端分开进行标记。 服务端发送消息，所有客户端都能统一接收（单聊）。 服务端可以指定单独某一个客户端接收消息（群发）。 服务端代码 服务端启动器 客户端代码","categories":[{"name":"Netty","slug":"Netty","permalink":"https://withoutcause.github.io/categories/Netty/"}],"tags":[{"name":"Netty","slug":"Netty","permalink":"https://withoutcause.github.io/tags/Netty/"}]},{"title":"关于Netty心语一二","slug":"关于Netty心语一二","date":"2021-07-30T15:53:57.000Z","updated":"2021-07-30T15:53:57.000Z","comments":true,"path":"2021/07/30/关于Netty心语一二/","link":"","permalink":"https://withoutcause.github.io/2021/07/30/%E5%85%B3%E4%BA%8ENetty%E5%BF%83%E8%AF%AD%E4%B8%80%E4%BA%8C/","excerpt":"我为什么学Netty我为什么学 Netty 我现在想想，当初最主要的原因还是因为焦虑。回想自己，2016 年怀着满腔热血到上海从事了第一份 Java 后端开发的工作。我清楚的记得那个时候因为 DBCP 连接池的一个参数，困惑了大概一个礼拜的时间。当初的原因是 DBCP 连接池的 class 配置项我放的值是数据库驱动类的全限定名，而这项配置应该是 class-name 这项配置。现在回想起来，那时候确实还挺菜的。所以要感谢亮 哥 和 龚总 对当时的我的收留。 今年年初的时候，算起自己已经是第五个年头了(从2016年实习开始算)，反省自己的时候再想：“我会什么？是不是把一年的经验重复了这四五年呢。”","text":"我为什么学Netty我为什么学 Netty 我现在想想，当初最主要的原因还是因为焦虑。回想自己，2016 年怀着满腔热血到上海从事了第一份 Java 后端开发的工作。我清楚的记得那个时候因为 DBCP 连接池的一个参数，困惑了大概一个礼拜的时间。当初的原因是 DBCP 连接池的 class 配置项我放的值是数据库驱动类的全限定名，而这项配置应该是 class-name 这项配置。现在回想起来，那时候确实还挺菜的。所以要感谢亮 哥 和 龚总 对当时的我的收留。 今年年初的时候，算起自己已经是第五个年头了(从2016年实习开始算)，反省自己的时候再想：“我会什么？是不是把一年的经验重复了这四五年呢。”","categories":[{"name":"Netty","slug":"Netty","permalink":"https://withoutcause.github.io/categories/Netty/"}],"tags":[{"name":"Netty","slug":"Netty","permalink":"https://withoutcause.github.io/tags/Netty/"},{"name":"非技术","slug":"非技术","permalink":"https://withoutcause.github.io/tags/%E9%9D%9E%E6%8A%80%E6%9C%AF/"}]},{"title":"Netty之HelloWorld","slug":"Netty之HelloWorld","date":"2021-07-30T15:26:35.000Z","updated":"2021-07-30T15:26:35.000Z","comments":true,"path":"2021/07/30/Netty之HelloWorld/","link":"","permalink":"https://withoutcause.github.io/2021/07/30/Netty%E4%B9%8BHelloWorld/","excerpt":"Netty 的 Hello World 案例分成两部分。一部分是服务端，将接收到的消息打印出来即可。另外一部分是客户端，发送消息。 服务端123456789101112131415161718192021222324252627282930313233public class Server &#123; public static void main(String[] args) &#123; EventLoopGroup boss = new NioEventLoopGroup(); EventLoopGroup worker = new NioEventLoopGroup(); try &#123; ServerBootstrap serverBootstrap = new ServerBootstrap(); serverBootstrap.group(boss, worker) .channel(NioServerSocketChannel.class) .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123; @Override protected void initChannel(NioSocketChannel nioSocketChannel) throws Exception &#123; nioSocketChannel.pipeline() .addLast(new StringDecoder()) .addLast(new SimpleChannelInboundHandler&lt;String&gt;() &#123; @Override protected void channelRead0(ChannelHandlerContext channelHandlerContext, String s) throws Exception &#123; System.out.println(&quot;server 接收到的消息&quot; + s); &#125; &#125;); &#125; &#125;); ChannelFuture channelFuture = serverBootstrap.bind(&quot;localhost&quot;, 8888); channelFuture.channel().closeFuture().sync(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; worker.shutdownGracefully(); boss.shutdownGracefully(); &#125; &#125;&#125;","text":"Netty 的 Hello World 案例分成两部分。一部分是服务端，将接收到的消息打印出来即可。另外一部分是客户端，发送消息。 服务端123456789101112131415161718192021222324252627282930313233public class Server &#123; public static void main(String[] args) &#123; EventLoopGroup boss = new NioEventLoopGroup(); EventLoopGroup worker = new NioEventLoopGroup(); try &#123; ServerBootstrap serverBootstrap = new ServerBootstrap(); serverBootstrap.group(boss, worker) .channel(NioServerSocketChannel.class) .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123; @Override protected void initChannel(NioSocketChannel nioSocketChannel) throws Exception &#123; nioSocketChannel.pipeline() .addLast(new StringDecoder()) .addLast(new SimpleChannelInboundHandler&lt;String&gt;() &#123; @Override protected void channelRead0(ChannelHandlerContext channelHandlerContext, String s) throws Exception &#123; System.out.println(&quot;server 接收到的消息&quot; + s); &#125; &#125;); &#125; &#125;); ChannelFuture channelFuture = serverBootstrap.bind(&quot;localhost&quot;, 8888); channelFuture.channel().closeFuture().sync(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; worker.shutdownGracefully(); boss.shutdownGracefully(); &#125; &#125;&#125; EventLoopGroup 创建了两个反应器线程组，分别为 boss 和 worker ，boss 接收到请求后交由 worker 处理。 ServerBootstrap 服务端引导器，服务端引导器主要是为了进行一些配置，主要有以下配置。 group 配置线程组 channel 配置通道类型 childHandler 配置一些 Handler 绑定的地址和端口 客户端123456789101112131415161718192021222324252627282930public class Client &#123; public static void main(String[] args) &#123; EventLoopGroup worker = new NioEventLoopGroup(); Bootstrap bootstrap = new Bootstrap(); try &#123; bootstrap.group(worker) .channel(NioSocketChannel.class) .option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT) .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; socketChannel.pipeline().addLast(new StringEncoder()); &#125; &#125;); ChannelFuture channelFuture = bootstrap.connect(&quot;localhost&quot;, 8888); Channel channel = channelFuture.channel(); while (true) &#123; String msg = LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME) + &quot;: Hello world!!!&quot;; channel.writeAndFlush(msg); TimeUnit.SECONDS.sleep(2); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; worker.shutdownGracefully(); &#125; &#125;&#125; NioEventLoopGroup 在客户端，只有 worker 线程组，没有 boss ，只需要配置一个 worker 即可。 其余与 服务端 大致类似。 最终效果，客户端控制台无任何输出。服务端控制台，每隔两秒钟就会打印当前时间 + Hello Wold 的字样。","categories":[{"name":"Netty","slug":"Netty","permalink":"https://withoutcause.github.io/categories/Netty/"}],"tags":[{"name":"Netty","slug":"Netty","permalink":"https://withoutcause.github.io/tags/Netty/"}]},{"title":"Netty组件","slug":"Netty组件","date":"2021-07-28T08:55:04.000Z","updated":"2021-07-28T08:55:04.000Z","comments":true,"path":"2021/07/28/Netty组件/","link":"","permalink":"https://withoutcause.github.io/2021/07/28/Netty%E7%BB%84%E4%BB%B6/","excerpt":"EventLoopGroup NioEventLoopGroup","text":"EventLoopGroup NioEventLoopGroup12EventLoopGroup boss = new NioEventLoopGroup();EventLoopGroup worker = new NioEventLoopGroup(); 创建的 boss 和 worker 就是 NioEventLoopGroup Bootstrap ServerBootstrap 服务端引导器 Bootstrap 客户端引导器 引导器的作用主要作用: boss 和 worker 的指定 设置 Channel 类型 Handler 设置 TCP 参数设置 端口绑定 ChannelNioServerSocketChannel 服务端 Channel 类型 NioSocketChannel 客户端 Channel 类型 Option 为 boss 设置 TCP 参数 ChildOption 为 worker 设置 TCP 参数 参数 含义 SO_KEEPALIVE 设置为 true 代表启用了 TCP SO_KEEPALIVE 属性，TCP 会主动探测连接状态，即连接保活 SO_BACKLOG 已完成三次握手的请求队列最大长度，同一时刻服务端可能会处理多个连接，在高并发海量连接的场景下，该参数应适当调大 TCP_NODELAY Netty 默认是 true，表示立即发送数据。如果设置为 false 表示启用 Nagle 算法，该算法会将 TCP 网络数据包累积到一定量才会发送，虽然可以减少报文发送的数量，但是会造成一定的数据延迟。Netty 为了最小化数据传输的延迟，默认禁用了 Nagle 算法 SO_SNDBUF TCP 数据发送缓冲区大小 SO_RCVBUF TCP数据接收缓冲区大小，TCP数据接收缓冲区大小 SO_LINGER 设置延迟关闭的时间，等待缓冲区中的数据发送完成 CONNECT_TIMEOUT_MILLIS 建立连接的超时时间 Handler ChannelInboundHandler入站处理器 ChannelOutboundHandler出站处理器 PiplineFuture&amp;PromiseByteBufByteBuf 的分类 池化/非池化的 ByteBuf 直接内存/堆内存的 ByteBuf Unsafe/非Unsafe的ByteBuf ByteBuf 的内部结构 readerIndex : 读指针 writrerIndexer : 写指针 maxCapactity : 最大容量 常用API对象创建 Unpooled Pooled 指针操作 readerIndex resetReaderIndex markReaderIndex writerIndex resetWriterIndex markWriterIndex setIndex 数据读写 isReadable isReadOnly asReadOnly readableBytes readBytes readSlice readRetainedSlice readType readByte() readChar() readBoolean() readShort() readInt() readLong() readFloat() readDouble() isWritable() writeBytes(ByteBuf src) writeCharSequence(CharSequence sequence, Charset charset) writeType writeBoolean(boolean value) writeByte(int value) writeShort(int value) writeInt(int value) writeLong(long value) writeChar(int value) writeFloat(float value) writeDouble(double value) 内存管理 refCnt() retain() retain(int increment) touch() touch(Object hint) release() release(int decrement)","categories":[{"name":"Netty","slug":"Netty","permalink":"https://withoutcause.github.io/categories/Netty/"}],"tags":[{"name":"Netty","slug":"Netty","permalink":"https://withoutcause.github.io/tags/Netty/"}]},{"title":"Reactor模型","slug":"Reactor模型","date":"2021-07-28T08:40:44.000Z","updated":"2021-07-28T08:42:59.051Z","comments":true,"path":"2021/07/28/Reactor模型/","link":"","permalink":"https://withoutcause.github.io/2021/07/28/Reactor%E6%A8%A1%E5%9E%8B/","excerpt":"Netty Reactor线程模型单线程 Reactor","text":"Netty Reactor线程模型单线程 Reactor acceptor 事件读取 dispatch 事件分发 read 读 send 发送 以上操作这都都是在一个线程里完成，缺陷很明显。一次只能由一个事件进行，该事件未完成，后面的事件只能无法执行。 多线程 Reactor 该模型由单线程 Reactor 模型改进而来，每个连接对应一个线程。后续的处理流程于单线程模型一致。 主从 Reactor MainReactor 只负责连接事件监听，当 client 连接以后，将后续的处理交给 SubReactor 来完成。与 Nginx 中的 master 进程原理一致，接收请求后本身不处理请求交由对应的 worker 来处理。 做 Netty 开发时，选择的都是主从 Reactor 模型。","categories":[{"name":"Netty","slug":"Netty","permalink":"https://withoutcause.github.io/categories/Netty/"}],"tags":[{"name":"Netty","slug":"Netty","permalink":"https://withoutcause.github.io/tags/Netty/"},{"name":"Reactor模型","slug":"Reactor模型","permalink":"https://withoutcause.github.io/tags/Reactor%E6%A8%A1%E5%9E%8B/"}]},{"title":"Optional","slug":"Optional","date":"2021-07-27T15:38:44.000Z","updated":"2021-07-28T09:38:20.942Z","comments":true,"path":"2021/07/27/Optional/","link":"","permalink":"https://withoutcause.github.io/2021/07/27/Optional/","excerpt":"问题12345678910111213141516171819202122232425262728293031323334public class A &#123; private B b; public B getB() &#123; return b; &#125; public void setB(B b) &#123; this.b = b; &#125;&#125;public class B &#123; private String bName; private String bAge; public String getbName() &#123; return bName; &#125; public void setbName(String bName) &#123; this.bName = bName; &#125; public String getbAge() &#123; return bAge; &#125; public void setbAge(String bAge) &#123; this.bAge = bAge; &#125;&#125; 已经存在两个类，并且互相嵌套，而且不允许修改， A 、B 两个类的结构，我们要安全的访问 A B中的值，尽可能少的使用 if 语句。","text":"问题12345678910111213141516171819202122232425262728293031323334public class A &#123; private B b; public B getB() &#123; return b; &#125; public void setB(B b) &#123; this.b = b; &#125;&#125;public class B &#123; private String bName; private String bAge; public String getbName() &#123; return bName; &#125; public void setbName(String bName) &#123; this.bName = bName; &#125; public String getbAge() &#123; return bAge; &#125; public void setbAge(String bAge) &#123; this.bAge = bAge; &#125;&#125; 已经存在两个类，并且互相嵌套，而且不允许修改， A 、B 两个类的结构，我们要安全的访问 A B中的值，尽可能少的使用 if 语句。 12345A a = null;Optional&lt;A&gt; a1 = Optional.ofNullable(a);Optional&lt;B&gt; b = a1.filter((t) -&gt; t.getB() != null).map(A::getB);// 上面一行代码的问题是， t 有可能会为 null ,从而引发 NPEB b2 = b.get(); 123456Optional&lt;A&gt; a1 = Optional.ofNullable(a);Optional&lt;B&gt; b = a1.map(A::getB);b.get(); // 有可能会抛异常,因为如果 b 为 null,那么得到的 Optional 为 empty 创建的b.orElse(new B()); // 没有问题，返回 new B 的对象b.orElseGet(() -&gt; B :: new); // 没有问题，返回 new B 的对象b.orElseThrow(() -&gt; YdException::new); // 手动抛出异常 使用 Optional 带来的变化123456789101112131415161718192021222324public class PersonNoOptional &#123; private Car car; public Car getCar() &#123; return car; &#125; public void setCar(Car car) &#123; this.car = car; &#125; public static class Car&#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; &#125;&#125; 上面的代码是没有使用 Optional 时候，我们经常会写的样式。会出现的问题： 如果某个值为 null，立马会报出 NPE 我们的解决方式 123456789101112public class OptionService &#123; public void opt() &#123; PersonNoOptional p = new PersonNoOptional(); PersonNoOptional.Car car = p.getCar(); if (car != null) &#123; // .... &#125; &#125; &#125; 会添加很多的 if 来进行判断，甚至还有空对象设计模式(Null Object Pattern) 来处理这一类的问题。Java 8 为我们带来了 Optional 添加新的解决方式。 1234567891011121314151617181920212223public class PersonOptional &#123; private Optional&lt;PersonNoOptional.Car&gt; car; public Optional&lt;PersonNoOptional.Car&gt; getCar() &#123; return car; &#125; public void setCar(PersonNoOptional.Car car) &#123; this.car = Optional.of(car); &#125; public static class Car &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; &#125;&#125; Peron 有可能会没有 Car，但是每一辆 Car 都必须有 name，所以我们对 Car 使用了 Optional 包装，而 name 没有使用 Optional 的原因就在这里。 Optional 的创建empty创建一个空的 Optional 对象 1Optional&lt;Object&gt; empty = Optional.empty(); empty() 方法的实现123456789private static final Optional&lt;?&gt; EMPTY = new Optional&lt;&gt;();private Optional() &#123; this.value = null; &#125;public static&lt;T&gt; Optional&lt;T&gt; empty() &#123; @SuppressWarnings(&quot;unchecked&quot;) Optional&lt;T&gt; t = (Optional&lt;T&gt;) EMPTY; return t;&#125; of1Optional&lt;B&gt; optionalB = Optional.of(new B()); of 方法中的参数如果为 null,会发生 NPE 1Optional&lt;Object&gt; optional = Optional.of(null); of() 方法的实现1234567891011121314// Objects.requireNonNull 的实现public static &lt;T&gt; T requireNonNull(T obj) &#123; if (obj == null) throw new NullPointerException(); return obj;&#125;private Optional(T value) &#123; this.value = Objects.requireNonNull(value);&#125;public static &lt;T&gt; Optional&lt;T&gt; of(T value) &#123; return new Optional&lt;&gt;(value);&#125; ofNullableofNullable 允许传入的参数为 null 12A a = null;Optional&lt;A&gt; optonal = Optional.ofNullable(a); ofNullable 的实现123public static &lt;T&gt; Optional&lt;T&gt; ofNullable(T value) &#123; return value == null ? empty() : of(value);&#125; #Optinal 中获取值 get1A a = optionalA.get(); 如果 Optional 容器中不存在值，会抛出异常 NoSuchElementException(&quot;No value present&quot;) get 的实现123456public T get() &#123; if (value == null) &#123; throw new NoSuchElementException(&quot;No value present&quot;); &#125; return value;&#125; orElse1A a = optionalA.orElse(new A()); 如果 Optional 容器中不存在值，使用 orElse 方法中定义的值。 orElse 的实现123public T orElse(T other) &#123; return value != null ? value : other;&#125; orElseGet1A a = optionalA.orElseGet(A::new); 如果 Optional 容器中不存在值，会执行定义的函数。 orElseGet 的实现123public T orElseGet(Supplier&lt;? extends T&gt; other) &#123; return value != null ? value : other.get();&#125; orElseThrow1A a = optionalA.orElseThrow(RuntimeException::new); 如果 Optional 容器中不存在值，会抛出指定的异常。与 get 方法的区别是，get 方法抛出的异常为固定的，该方法可以抛出指定的异常。 orElseThrow 的实现1234567public &lt;X extends Throwable&gt; T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) throws X &#123; if (value != null) &#123; return value; &#125; else &#123; throw exceptionSupplier.get(); &#125;&#125; 当 Optional 容器中的值为空时，使用了 throw 关键字。 map 和 flatMapmap1234567891011121314151617181920212223242526272829303132333435363738public class A &#123; private B b; public B getB() &#123; return b; &#125;&#125;public class B &#123; private Name bName; private String bAge; public Name getbName() &#123; return bName; &#125; public void setbName(Name bName) &#123; this.bName = bName; &#125; public String getbAge() &#123; return bAge; &#125; public void setbAge(String bAge) &#123; this.bAge = bAge; &#125; public static class Name&#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; &#125;&#125; A B 两个类的结构关系是互相嵌套，我们要取出 b.Name.getName() 的值 1234Optional&lt;String&gt; aName = optionalA.map(A::getB) .map(B::getbName) .map(B.Name::getName);System.out.println(aName.orElse(&quot;kkk&quot;)); flatMap如果 B 在 A 的嵌套中，使用了 Optional 包装 12345678public class A &#123; private Optional&lt;B&gt; b; public Optional&lt;B&gt; getB() &#123; return b; &#125;&#125; 再使用上面的访问，就会编译报错。 原因: 1Optional&lt;Optional&lt;B&gt;&gt; optional = optionalA.map(A::getB); map 的返回外面被包装了一层 Optional ，想要达到上面的效果，需要拆掉一层 Optional 的包装，那么此时就可以使用 flatMap 来打散一层 Optional 的包装 1234String kkk = optionalA.flatMap(A::getB) .map(B::getbName) .map(B.Name::getName) .orElse(&quot;kkk&quot;); ypxh就可以顺利访问了 map 和 flatMap 的区别在于，flatMap 会进行拆包(将外面的层包装拆除)的动作，而 map 不会进行拆包 Optional 提供的其他方法isPresentisPresent 用于判断 Optional 容器中值是否为空(null)，不为空返回会 true，空返回 false 123public boolean isPresent() &#123; return value != null;&#125; ifPresentifPresent 提供了执行函数式代码的能力，当 Optional 容器中的值不为空时，会执行传入的函数式代码。 1optionalA.ifPresent(c -&gt; System.out.println(c.getB())); ifPresent 的实现1234public void ifPresent(Consumer&lt;? super T&gt; consumer) &#123; if (value != null) consumer.accept(value);&#125; filter通过执行传入的谓词 进行过滤，如果传入的 谓词 执行结果为 true 返回 Optional 容器本身，否则返回空容器。 1234567public Optional&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate) &#123; Objects.requireNonNull(predicate); if (!isPresent()) return this; else return predicate.test(value) ? this : empty();&#125;","categories":[{"name":"java8","slug":"java8","permalink":"https://withoutcause.github.io/categories/java8/"}],"tags":[{"name":"optional","slug":"optional","permalink":"https://withoutcause.github.io/tags/optional/"},{"name":"java8","slug":"java8","permalink":"https://withoutcause.github.io/tags/java8/"}]},{"title":"http协议","slug":"http协议","date":"2021-07-21T08:47:37.000Z","updated":"2021-07-28T09:40:04.000Z","comments":true,"path":"2021/07/21/http协议/","link":"","permalink":"https://withoutcause.github.io/2021/07/21/http%E5%8D%8F%E8%AE%AE/","excerpt":"[TOC] HTTP协议客户端(Client)","text":"[TOC] HTTP协议客户端(Client) 发起 http 请求的一方称为客户端，一般是浏览器，比如常见的 Chrome、360浏览器、MicroSoft Edge、Safair浏览器 等；除了浏览器还有一些能够发起 http 请求的软件，比如: postman、Jmeter 等。 服务端(Server) 提供 http 服务的一方称为 服务端，一般是各种 Web服务器。 http 请求是请求-响应模式，也就是一发出一次请求，会收到一次应签。 客户端和服务端通信 HTTP协议规定，请求从客户端发出，最后服务器端响应该请求并返回。先从客户端开始建立通信的，服务器端在没有接收到请求之前不会发送响应。 请求报文12GET /index.html HTTP/1.1Host: 127.0.0.1 请求报文是由请求方法、请求URI、协议版本、可选的请求首部字段和内容实体构成的。 响应报文1234567HTTP/1.1200 OKDate: Tue, 10 Jul 2012 06:50:15 GMTContent-Length: 362Content-Type: text/html&lt;html&gt;...&lt;/html&gt; 响应报文基本上由协议版本、状态码（表示请求成功或失败的数字代码）、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成。稍后我们会对这些内容进行详细说明。 http无状态 HTTP协议自身不对请求和响应之间的通信状态进行保存。也就是说在HTTP这个级别，协议对于发送过的请求或响应都不做持久化处理。 使用HTTP协议，每当有新的请求发送时，就会有对应的新响应产生。协议本身并不保留之前一切的请求或响应报文的信息。 在很多情况下，我们需要一些状态。比如用户是否已经登录，就需要使用 Cookie 做一些存储。 URL(URI) url 对资源进行定位 1http://www.baidu.com http method(请求方法) 请求方法 说明 GET 获取资源 POST 传输实体 PUT 传输文件(在 Restful 中主要用于修改资源) DELETE 删除文件 OPTIONS 询问支持的方法 TRACE 追踪 CONNECT 建立连接 HTTP 协议报文 http协议分为头部和主体，中间用一个空行隔开。 请求 请求行，包含请求的方法，请求的 url 和协议版本号 状态行，http 请求的响应状态 头部字段，一些标准的或者自定义的 http 头字段 其他 响应状态码 状态码 类别 描述 1xx Informational(信息状态码) 接收的请求正在处理 2xx Success(成功状态码) 请求正常处理完毕 3xx Redirection(重定向状态码) 需要请求其他操作 4xx Client Error(客户端错误) 服务器无法处理请求 5xx Server Error(服务端错误) 服务器处理请求出错 2xx 200: ok 请求成功 204: Not Content 206: Partial Content 3xx 301: Moved Permanently，永久重定向 302: Found，临时重定向 303: See Other，对应另外一个资源，应该由 GET 请求去获取 304: Not Modified，虽然同属 3xx 系列，但是与重定向无关。含义：服务端资源未改变，可直接使用客户端未过期缓存。 307: Temporary Redirect，临时重定向，与 302 含义相同，但是如果发起的是 POST 请求，重定向时不会改成 GET(301、302会将 POST 请求改成 GET) 4xx 400: Bad Request，请求报文中存在语法错误 401: Unauthorized，没有通过认证 403: Forbidden，请求被拒绝 404: Not Found，资源无法找到 5xx 500: Internal Server Error，服务器内部发错误 502: Bad Gateway，网关错误 503: Service Unavliaable，服务不可访问(有可能是服务端负载过高) http请求头字段Cache-Control 操作缓存 1Cache-Control: private public，所有人都可以使用该缓存 private，对特定用户使用缓存 no-cache，不使用缓存，如果有缓存不会向服务器验证该缓存。 请求中包含 no-cache 代表不从缓存中接收响应。 响应中包含 no-cache 代表不能将响应缓存。 1Cache-Control: no-cache no-cache=名称，对指定字段不进行缓存 1Cache-Control: no-cache=Location no-store，不使用缓存 ，这个字段的真正含义是不使用缓存，对 no-cache 是有一定区别的。 max-age，指定缓存时间；如果当 max-age=0 时，表示缓存过期必须将该请求交给服务器而不是缓存服务器进行处理。 s-maxage，这个字段有点懵，在致意思和 max-age 类似。 min-fresh，指定多少秒以内未过期的资源。例如: Cache-Control: min-fresh=60 返回 60 秒内未过期的数据。 max-stable，如果为空表示无论过期多久的数据都接收，如果指定具体时间则表示接收指定时间内的过期数据。 only-if-cached，懵的 must-revalidate，代理服务器验证缓存的响应信息。 proxy-revalidate，缓存服务器返回响应之前，再次验证缓存的有效性。 no-transform，禁止缓存转换媒体类型。 扩展， 1Cache-Control: private, Community=&quot;UCI&quot; 扩展了 Community 字段，如果服务器能处理则会处理，不能处理会默认丢掉该字段。 ConnectionConnection 有两个作用: 控制不再转发给代理的头部字段 管理持久链接 不转发字段: 1Connection: Upgrade 不再转发 Upgrade 字段的内容，同时 Upgrade 表示协议升级，一般是从 http 升级到 websocket 协议。 管理持久链接 Close，告诉服务端需要和它断开链接。 Keep-Alive，维持持久链接。 Date表明创建 http报文 的日期。 1Date: Mon, 26 Jul 2021 13:31:04 GMT Transfer-Encoding规定了传输报文时采用的编码方式。 1Transfer-Encoding: chunked Upgrade一般用于切换协议或升级协议，对于切换协议，服务器会响应一个 101 状态码。 Accept告诉服务器，客户端能够处理的媒体类型以及对应的优先级(权重)。 1Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 这里的内容是以 ,逗号 进行分隔且默认的 q=1.0。 参考内容:https://time.geekbang.org/column/article/104024 Accept-Encoding gzip compress default identity Accept-Language指定返回的字符集 Authorizationhttp 认证字段，在浏览器返回 401 的情况下需要加该字段。 1Authorization: Basic xxdfhaofaoifjklasdfwsaytropqw Host请求的资源的主机名和端口号 1Host: www.baidu.com http响应头字段Accept-Range用来告知客户端服务器是否能处理范围请求，以指定获取服务器端某个部分的资源。 bytes ：可以处理 none：不能处理 Age告知客户端，源服务端在多久前创建的响应。单位：秒 1Age: 60 ETagLocation1Location: https://www.baidu.com 对该值进行重定向访问，一般配合 3xx 响应状态码使用。 Proxy-Authenticate1Proxy-Authenticate: Basic realm=&quot;Usingauth xxxx&quot; 代理服务器的认证信息发送给客户端。 Retry-After在多少秒之后再次发起请求。单位：秒，字段值也可以指定具体的秒。 1Retry-After: 120 Server告诉客户端服务的应用程序相关信息，一般会显示服务端使用的软件，版本号会隐藏。 1server: nginx Content-Encoding告诉客户端，对实体采用的压缩格式。采用最多的是 gzip 。 Content-Language告诉客户端，语言类型 1Content-Language: zh-CN Content-Type说明媒体类型，charset 用于指定字符类集。 CookieCookie发起请求时，头部字段带的。 Set-Cookie响应结果时，响应头带的。 Cookie的属性NAME=VALUE对 cookie 进行赋值 expires指定 cookie 的过期时间，不设就表明直到浏览器关闭之前有效。 path指定 cookie 的发送范围，一般是 / 斜杠。 domainCookie 适用的域名，不写默认是创建 cookie 的域名。 secure只有在使用 https 时才可以发送 cookie 。 1Set-Cookie: name=value; Secure HttpOnlyjs脚本无法操作 cookie 1Set-Cookie: name=value; HttpOnaly","categories":[{"name":"http","slug":"http","permalink":"https://withoutcause.github.io/categories/http/"}],"tags":[{"name":"http","slug":"http","permalink":"https://withoutcause.github.io/tags/http/"}]}],"categories":[{"name":"ES","slug":"ES","permalink":"https://withoutcause.github.io/categories/ES/"},{"name":"并发","slug":"并发","permalink":"https://withoutcause.github.io/categories/%E5%B9%B6%E5%8F%91/"},{"name":"项目实践","slug":"项目实践","permalink":"https://withoutcause.github.io/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/"},{"name":"数据库","slug":"数据库","permalink":"https://withoutcause.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MongoDB","slug":"数据库/MongoDB","permalink":"https://withoutcause.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MongoDB/"},{"name":"ts","slug":"ts","permalink":"https://withoutcause.github.io/categories/ts/"},{"name":"心得","slug":"心得","permalink":"https://withoutcause.github.io/categories/%E5%BF%83%E5%BE%97/"},{"name":"React","slug":"React","permalink":"https://withoutcause.github.io/categories/React/"},{"name":"k8s","slug":"k8s","permalink":"https://withoutcause.github.io/categories/k8s/"},{"name":"yaml","slug":"yaml","permalink":"https://withoutcause.github.io/categories/yaml/"},{"name":"Docker","slug":"Docker","permalink":"https://withoutcause.github.io/categories/Docker/"},{"name":"踩过的坑","slug":"踩过的坑","permalink":"https://withoutcause.github.io/categories/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"},{"name":"git","slug":"git","permalink":"https://withoutcause.github.io/categories/git/"},{"name":"Linux","slug":"Linux","permalink":"https://withoutcause.github.io/categories/Linux/"},{"name":"Shell","slug":"Linux/Shell","permalink":"https://withoutcause.github.io/categories/Linux/Shell/"},{"name":"流量回放","slug":"流量回放","permalink":"https://withoutcause.github.io/categories/%E6%B5%81%E9%87%8F%E5%9B%9E%E6%94%BE/"},{"name":"Netty","slug":"Netty","permalink":"https://withoutcause.github.io/categories/Netty/"},{"name":"IDEA","slug":"IDEA","permalink":"https://withoutcause.github.io/categories/IDEA/"},{"name":"MapStruct","slug":"MapStruct","permalink":"https://withoutcause.github.io/categories/MapStruct/"},{"name":"java8","slug":"java8","permalink":"https://withoutcause.github.io/categories/java8/"},{"name":"http","slug":"http","permalink":"https://withoutcause.github.io/categories/http/"}],"tags":[{"name":"ES","slug":"ES","permalink":"https://withoutcause.github.io/tags/ES/"},{"name":"并发","slug":"并发","permalink":"https://withoutcause.github.io/tags/%E5%B9%B6%E5%8F%91/"},{"name":"多线程","slug":"多线程","permalink":"https://withoutcause.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"架构","slug":"架构","permalink":"https://withoutcause.github.io/tags/%E6%9E%B6%E6%9E%84/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://withoutcause.github.io/tags/MongoDB/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://withoutcause.github.io/tags/TypeScript/"},{"name":"ts","slug":"ts","permalink":"https://withoutcause.github.io/tags/ts/"},{"name":"经验","slug":"经验","permalink":"https://withoutcause.github.io/tags/%E7%BB%8F%E9%AA%8C/"},{"name":"心得","slug":"心得","permalink":"https://withoutcause.github.io/tags/%E5%BF%83%E5%BE%97/"},{"name":"React","slug":"React","permalink":"https://withoutcause.github.io/tags/React/"},{"name":"Ajax","slug":"Ajax","permalink":"https://withoutcause.github.io/tags/Ajax/"},{"name":"axios","slug":"axios","permalink":"https://withoutcause.github.io/tags/axios/"},{"name":"k8s","slug":"k8s","permalink":"https://withoutcause.github.io/tags/k8s/"},{"name":"yaml","slug":"yaml","permalink":"https://withoutcause.github.io/tags/yaml/"},{"name":"yml","slug":"yml","permalink":"https://withoutcause.github.io/tags/yml/"},{"name":"k8s配置","slug":"k8s配置","permalink":"https://withoutcause.github.io/tags/k8s%E9%85%8D%E7%BD%AE/"},{"name":"Docker","slug":"Docker","permalink":"https://withoutcause.github.io/tags/Docker/"},{"name":"IDEA","slug":"IDEA","permalink":"https://withoutcause.github.io/tags/IDEA/"},{"name":"踩坑","slug":"踩坑","permalink":"https://withoutcause.github.io/tags/%E8%B8%A9%E5%9D%91/"},{"name":"泛型擦除","slug":"泛型擦除","permalink":"https://withoutcause.github.io/tags/%E6%B3%9B%E5%9E%8B%E6%93%A6%E9%99%A4/"},{"name":"git","slug":"git","permalink":"https://withoutcause.github.io/tags/git/"},{"name":"hook","slug":"hook","permalink":"https://withoutcause.github.io/tags/hook/"},{"name":"Linux","slug":"Linux","permalink":"https://withoutcause.github.io/tags/Linux/"},{"name":"Shell","slug":"Shell","permalink":"https://withoutcause.github.io/tags/Shell/"},{"name":"流量回放","slug":"流量回放","permalink":"https://withoutcause.github.io/tags/%E6%B5%81%E9%87%8F%E5%9B%9E%E6%94%BE/"},{"name":"Netty","slug":"Netty","permalink":"https://withoutcause.github.io/tags/Netty/"},{"name":"MapStruct","slug":"MapStruct","permalink":"https://withoutcause.github.io/tags/MapStruct/"},{"name":"非技术","slug":"非技术","permalink":"https://withoutcause.github.io/tags/%E9%9D%9E%E6%8A%80%E6%9C%AF/"},{"name":"Reactor模型","slug":"Reactor模型","permalink":"https://withoutcause.github.io/tags/Reactor%E6%A8%A1%E5%9E%8B/"},{"name":"optional","slug":"optional","permalink":"https://withoutcause.github.io/tags/optional/"},{"name":"java8","slug":"java8","permalink":"https://withoutcause.github.io/tags/java8/"},{"name":"http","slug":"http","permalink":"https://withoutcause.github.io/tags/http/"}]}